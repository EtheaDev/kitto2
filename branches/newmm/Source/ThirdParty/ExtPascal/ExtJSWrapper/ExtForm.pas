unit ExtForm;

// Generated by ExtToPascal v.0.9.8, at 3/5/2010 11:59:34
// from "C:\Trabalho\ext\docs\output" detected as ExtJS v.3

interface

uses
  StrUtils, ExtPascal, ExtPascalUtils, ExtUtil, Ext, ExtData;

type
  TExtFormAction = class;
  TExtFormVTypesSingleton = class;
  TExtFormBasicForm = class;
  TExtUxGridRecordForm = class;
  TExtFormActionSubmit = class;
  TExtFormActionLoad = class;
  TExtFormActionDirectLoad = class;
  TExtFormActionDirectSubmit = class;
  TExtFormField = class;
  TExtFormLabel = class;
  TExtFormHidden = class;
  TExtFormHtmlEditor = class;
  TExtUxCodePress = class;
  TExtFormTextField = class;
  TExtFormSliderField = class;
  TExtFormDisplayField = class;
  TExtFormCompositeField = class;
  TExtFormCheckbox = class;
  TExtFormCheckboxGroup = class;
  TExtFormTextArea = class;
  TExtFormTriggerField = class;
  TExtFormNumberField = class;
  TExtFormFieldSet = class;
  TExtFormFormPanel = class;
  TExtFormRadioGroup = class;
  TExtFormRadio = class;
  TExtFormDateField = class;
  TExtFormComboBox = class;
  TExtFormTwinTriggerField = class;
  TExtFormTimeField = class;
  TExtUxFormLovCombo = class;

  TExtFormAction = class(TExtFunction)
  private
    FFailure : TExtFunction;
    FMethod : String;
    FParams : String;
    FReset : Boolean;
    FScope : TExtObject;
    FSubmitEmptyText : Boolean;
    FSuccess : TExtFunction;
    FTimeout : Integer;
    FUrl : String;
    FWaitMsg : String;
    FWaitTitle : String;
    FFailureType : String;
    FResponse : TExtObject;
    FResultJS : TExtObject;
    FTypeJS : String;
    procedure SetFFailure(Value : TExtFunction);
    procedure SetFMethod(Value : String);
    procedure SetFParams(Value : String);
    procedure SetFReset(Value : Boolean);
    procedure SetFScope(Value : TExtObject);
    procedure SetFSubmitEmptyText(Value : Boolean);
    procedure SetFSuccess(Value : TExtFunction);
    procedure SetFTimeout(Value : Integer);
    procedure SetFUrl(Value : String);
    procedure SetFWaitMsg(Value : String);
    procedure SetFWaitTitle(Value : String);
    procedure SetFFailureType(Value : String);
    procedure SetFResponse(Value : TExtObject);
    procedure SetFResultJS(Value : TExtObject);
    procedure SetFTypeJS(Value : String);
  public
    function JSClassName : string; override;
    class function CLIENT_INVALID : String;
    class function CONNECT_FAILURE : String;
    class function LOAD_FAILURE : String;
    class function SERVER_INVALID : String;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Failure : TExtFunction read FFailure write SetFFailure;
    property Method : String read FMethod write SetFMethod;
    property Params : String read FParams write SetFParams;
    property Reset : Boolean read FReset write SetFReset;
    property Scope : TExtObject read FScope write SetFScope;
    property SubmitEmptyText : Boolean read FSubmitEmptyText write SetFSubmitEmptyText;
    property Success : TExtFunction read FSuccess write SetFSuccess;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property Url : String read FUrl write SetFUrl;
    property WaitMsg : String read FWaitMsg write SetFWaitMsg;
    property WaitTitle : String read FWaitTitle write SetFWaitTitle;
    property FailureType : String read FFailureType write SetFFailureType;
    property Response : TExtObject read FResponse write SetFResponse;
    property ResultJS : TExtObject read FResultJS write SetFResultJS;
    property TypeJS : String read FTypeJS write SetFTypeJS;
  end;

  TExtFormVTypesSingleton = class(TExtFunction)
  private
    FAlphaMask : TRegExp;
    FAlphaText : String;
    FAlphanumMask : TRegExp;
    FAlphanumText : String;
    FEmailMask : TRegExp;
    FEmailText : String;
    FUrlText : String;
    procedure SetFAlphaMask(Value : TRegExp);
    procedure SetFAlphaText(Value : String);
    procedure SetFAlphanumMask(Value : TRegExp);
    procedure SetFAlphanumText(Value : String);
    procedure SetFEmailMask(Value : TRegExp);
    procedure SetFEmailText(Value : String);
    procedure SetFUrlText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Alpha(Value : String) : TExtFunction;
    function Alphanum(Value : String) : TExtFunction;
    function Email(Value : String) : TExtFunction;
    function Url(Value : String) : TExtFunction;
    property AlphaMask : TRegExp read FAlphaMask write SetFAlphaMask;
    property AlphaText : String read FAlphaText write SetFAlphaText;
    property AlphanumMask : TRegExp read FAlphanumMask write SetFAlphanumMask;
    property AlphanumText : String read FAlphanumText write SetFAlphanumText;
    property EmailMask : TRegExp read FEmailMask write SetFEmailMask;
    property EmailText : String read FEmailText write SetFEmailText;
    property UrlText : String read FUrlText write SetFUrlText;
  end;

  // Procedural types for events TExtFormBasicForm
  TExtFormBasicFormOnActioncomplete = procedure(This : TExtFormBasicForm; Action : TExtAction) of object;
  TExtFormBasicFormOnActionfailed = procedure(This : TExtFormBasicForm; Action : TExtAction) of object;
  TExtFormBasicFormOnBeforeaction = procedure(This : TExtFormBasicForm; Action : TExtAction) of object;

  TExtFormBasicForm = class(TExtUtilObservable)
  private
    FApi : TExtObject;
    FBaseParams : TExtObject;
    FErrorReader : TExtDataDataReader;
    FFileUpload : Boolean;
    FMethod : String;
    FParamOrder : TExtObjectList;
    FParamOrderString : String;
    FParamsAsHash : Boolean;
    FReader : TExtDataDataReader;
    FStandardSubmit : Boolean;
    FTimeout : Integer;
    FTrackResetOnLoad : Boolean;
    FUrl : String;
    FWaitTitle : String; // 'Please Wait...'
    FItems : TExtObjectList;
    FWaitMsgTarget : String;
    FOnActioncomplete : TExtFormBasicFormOnActioncomplete;
    FOnActionfailed : TExtFormBasicFormOnActionfailed;
    FOnBeforeaction : TExtFormBasicFormOnBeforeaction;
    procedure SetFApi(Value : TExtObject);
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFErrorReader(Value : TExtDataDataReader);
    procedure SetFFileUpload(Value : Boolean);
    procedure SetFMethod(Value : String);
    procedure SetFParamOrder(Value : TExtObjectList);
    procedure SetFParamOrderString(Value : String);
    procedure SetFParamsAsHash(Value : Boolean);
    procedure SetFReader(Value : TExtDataDataReader);
    procedure SetFStandardSubmit(Value : Boolean);
    procedure SetFTimeout(Value : Integer);
    procedure SetFTrackResetOnLoad(Value : Boolean);
    procedure SetFUrl(Value : String);
    procedure SetFWaitTitle(Value : String);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFWaitMsgTarget(Value : String);
    procedure SetFOnActioncomplete(Value : TExtFormBasicFormOnActioncomplete);
    procedure SetFOnActionfailed(Value : TExtFormBasicFormOnActionfailed);
    procedure SetFOnBeforeaction(Value : TExtFormBasicFormOnBeforeaction);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Add(Fields : TExtObjectList = nil) : TExtFunction;
    function ApplyIfToFields(Values : TExtObject) : TExtFunction;
    function ApplyToFields(Values : TExtObject) : TExtFunction;
    function CleanDestroyed : TExtFunction;
    function ClearInvalid : TExtFunction;
    function DoAction(ActionName : String; Options : TExtObject = nil) : TExtFunction; overload;
    function DoAction(ActionName : TExtObject; Options : TExtObject = nil) : TExtFunction; overload;
    function FindField(Id : String) : TExtFunction;
    function GetEl : TExtFunction;
    function GetFieldValues(DirtyOnly : Boolean = false) : TExtFunction;
    function GetValues(AsString : Boolean = false) : TExtFunction;
    function IsDirty : TExtFunction;
    function IsValid : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction;
    function LoadRecord(RecordJS : TExtDataRecord) : TExtFunction;
    function MarkInvalid(Errors : TExtObjectList) : TExtFunction; overload;
    function MarkInvalid(Errors : TExtObject) : TExtFunction; overload;
    function Remove(Field : TExtFormField) : TExtFunction;
    function Render : TExtFunction;
    function Reset : TExtFunction;
    function SetValues(Values : TExtObjectList) : TExtFunction; overload;
    function SetValues(Values : TExtObject) : TExtFunction; overload;
    function Submit(Options : TExtObject) : TExtFunction;
    function UpdateRecord(RecordJS : TExtDataRecord) : TExtFunction;
    destructor Destroy; override;
    property Api : TExtObject read FApi write SetFApi;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property ErrorReader : TExtDataDataReader read FErrorReader write SetFErrorReader;
    property FileUpload : Boolean read FFileUpload write SetFFileUpload;
    property Method : String read FMethod write SetFMethod;
    property ParamOrder : TExtObjectList read FParamOrder write SetFParamOrder;
    property ParamOrderString : String read FParamOrderString write SetFParamOrderString;
    property ParamsAsHash : Boolean read FParamsAsHash write SetFParamsAsHash;
    property Reader : TExtDataDataReader read FReader write SetFReader;
    property StandardSubmit : Boolean read FStandardSubmit write SetFStandardSubmit;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property TrackResetOnLoad : Boolean read FTrackResetOnLoad write SetFTrackResetOnLoad;
    property Url : String read FUrl write SetFUrl;
    property WaitTitle : String read FWaitTitle write SetFWaitTitle;
    property Items : TExtObjectList read FItems write SetFItems;
    property WaitMsgTarget : String read FWaitMsgTarget write SetFWaitMsgTarget;
    property OnActioncomplete : TExtFormBasicFormOnActioncomplete read FOnActioncomplete write SetFOnActioncomplete;
    property OnActionfailed : TExtFormBasicFormOnActionfailed read FOnActionfailed write SetFOnActionfailed;
    property OnBeforeaction : TExtFormBasicFormOnBeforeaction read FOnBeforeaction write SetFOnBeforeaction;
  end;

  TExtUxGridRecordForm = class(TExtUtilObservable)
  private
    FCancelIconCls : String; // 'icon-cancel'
    FCancelText : String; // 'Cancel'
    FColumnCount : Integer; // 1
    FDirtyRowCls : String; // 'ux-grid3-dirty-row'
    FIconCls : String;
    FOkIconCls : String; // 'icon-ok'
    FOkText : String; // 'OK'
    FNewRowCls : String; // 'ux-grid3-new-row'
    FTitle : String;
    FShowButtons : Boolean; // true
    FIgnoreFields : TExtObject;
    FReadonlyFields : TExtObject;
    FDisabledFields : TExtObject;
    FFormConfig : TExtObject;
    procedure SetFCancelIconCls(Value : String);
    procedure SetFCancelText(Value : String);
    procedure SetFColumnCount(Value : Integer);
    procedure SetFDirtyRowCls(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFOkIconCls(Value : String);
    procedure SetFOkText(Value : String);
    procedure SetFNewRowCls(Value : String);
    procedure SetFTitle(Value : String);
    procedure SetFShowButtons(Value : Boolean);
    procedure SetFIgnoreFields(Value : TExtObject);
    procedure SetFReadonlyFields(Value : TExtObject);
    procedure SetFDisabledFields(Value : TExtObject);
    procedure SetFFormConfig(Value : TExtObject);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Show(DataRecord : TExtDataRecord; AnimEl : TExtElement = nil) : TExtFunction;
    property CancelIconCls : String read FCancelIconCls write SetFCancelIconCls;
    property CancelText : String read FCancelText write SetFCancelText;
    property ColumnCount : Integer read FColumnCount write SetFColumnCount;
    property DirtyRowCls : String read FDirtyRowCls write SetFDirtyRowCls;
    property IconCls : String read FIconCls write SetFIconCls;
    property OkIconCls : String read FOkIconCls write SetFOkIconCls;
    property OkText : String read FOkText write SetFOkText;
    property NewRowCls : String read FNewRowCls write SetFNewRowCls;
    property Title : String read FTitle write SetFTitle;
    property ShowButtons : Boolean read FShowButtons write SetFShowButtons;
    property IgnoreFields : TExtObject read FIgnoreFields write SetFIgnoreFields;
    property ReadonlyFields : TExtObject read FReadonlyFields write SetFReadonlyFields;
    property DisabledFields : TExtObject read FDisabledFields write SetFDisabledFields;
    property FormConfig : TExtObject read FFormConfig write SetFFormConfig;
  end;

  TExtFormActionSubmit = class(TExtFormAction)
  private
    FClientValidation : Boolean;
    FErrorReader : TExtDataDataReader;
    procedure SetFClientValidation(Value : Boolean);
    procedure SetFErrorReader(Value : TExtDataDataReader);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property ClientValidation : Boolean read FClientValidation write SetFClientValidation;
    property ErrorReader : TExtDataDataReader read FErrorReader write SetFErrorReader;
  end;

  TExtFormActionLoad = class(TExtFormAction)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormActionDirectLoad = class(TExtFormActionLoad)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormActionDirectSubmit = class(TExtFormActionSubmit)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtFormField
  TExtFormFieldOnBlur = procedure(This : TExtFormField) of object;
  TExtFormFieldOnChange = procedure(This : TExtFormField; NewValue : String; OldValue : String) of object;
  TExtFormFieldOnFocus = procedure(This : TExtFormField) of object;
  TExtFormFieldOnInvalid = procedure(This : TExtFormField; Msg : String) of object;
  TExtFormFieldOnSpecialkey = procedure(This : TExtFormField; E : TExtEventObjectSingleton) of object;
  TExtFormFieldOnValid = procedure(This : TExtFormField) of object;

  // Enumerated types for properties
  TExtFormFieldInputType = (itText, itButton, itCheckbox, itFile, itHidden, itImage, itPassword, itRadio, itReset, itSubmit);

  TExtFormField = class(TExtBoxComponent)
  private
    FAutoCreate : String;
    FAutoCreateObject : TExtObject;
    FCls : String;
    FDisabled : Boolean;
    FFieldClass : String; // 'x-form-field'
    FFocusClass : String; // 'x-form-focus'
    FInputType : TExtFormFieldInputType; // 'text'
    FInvalidClass : String; // 'x-form-invalid'
    FInvalidText : String; // 'The value in this field is invalid'
    FMsgFx : String; // 'normal'
    FMsgTarget : String;
    FName : String;
    FPreventMark : Boolean;
    FReadOnly : Boolean;
    FSubmitValue : Boolean;
    FTabIndex : Integer;
    FValidateOnBlur : Boolean; // true
    FValidationDelay : Integer; // 250
    FValidationEvent : String; // 'keyup'
    FValidationEventBoolean : Boolean;
    FValue : String;
    FLabelJS : TExtElement;
    FOriginalValue : String;
    FStartValue : String;
    FOnBlur : TExtFormFieldOnBlur;
    FOnChange : TExtFormFieldOnChange;
    FOnFocus : TExtFormFieldOnFocus;
    FOnInvalid : TExtFormFieldOnInvalid;
    FOnSpecialkey : TExtFormFieldOnSpecialkey;
    FOnValid : TExtFormFieldOnValid;
    procedure SetFAutoCreate(Value : String);
    procedure SetFAutoCreateObject(Value : TExtObject);
    procedure SetFCls(Value : String);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFFieldClass(Value : String);
    procedure SetFFocusClass(Value : String);
    procedure SetFInputType(Value : TExtFormFieldInputType);
    procedure SetFInvalidClass(Value : String);
    procedure SetFInvalidText(Value : String);
    procedure SetFMsgFx(Value : String);
    procedure SetFMsgTarget(Value : String);
    procedure SetFName(Value : String);
    procedure SetFPreventMark(Value : Boolean);
    procedure SetFReadOnly(Value : Boolean);
    procedure SetFSubmitValue(Value : Boolean);
    procedure SetFTabIndex(Value : Integer);
    procedure SetFValidateOnBlur(Value : Boolean);
    procedure SetFValidationDelay(Value : Integer);
    procedure SetFValidationEvent(Value : String);
    procedure SetFValidationEventBoolean(Value : Boolean);
    procedure SetFValue(Value : String);
    procedure SetFLabelJS(Value : TExtElement);
    procedure SetFOriginalValue(Value : String);
    procedure SetFStartValue(Value : String);
    procedure SetFOnBlur(Value : TExtFormFieldOnBlur);
    procedure SetFOnChange(Value : TExtFormFieldOnChange);
    procedure SetFOnFocus(Value : TExtFormFieldOnFocus);
    procedure SetFOnInvalid(Value : TExtFormFieldOnInvalid);
    procedure SetFOnSpecialkey(Value : TExtFormFieldOnSpecialkey);
    procedure SetFOnValid(Value : TExtFormFieldOnValid);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function ClearInvalid : TExtFunction;
    function GetActiveError : TExtFunction;
    function GetErrors : TExtFunction;
    function GetName : TExtFunction;
    function GetRawValue : TExtFunction;
    function GetValue : TExtFunction;
    function IsDirty : TExtFunction;
    function IsValid(PreventMark : Boolean) : TExtFunction;
    function MarkInvalid(Msg : String = '') : TExtFunction;
    function ProcessValue(Value : String) : TExtFunction;
    function Reset : TExtFunction;
    function SetActiveError(Msg : String; SuppressEvent : Boolean) : TExtFunction;
    function SetRawValue(Value : String) : TExtFunction;
    function SetReadOnly(ReadOnly : Boolean) : TExtFunction;
    function SetValue(Value : String) : TExtFunction;
    function UnsetActiveError(SuppressEvent : Boolean) : TExtFunction;
    function Validate : TExtFunction;
    function ValidateValue(The : String) : TExtFunction;
    destructor Destroy; override;
    property AutoCreate : String read FAutoCreate write SetFAutoCreate;
    property AutoCreateObject : TExtObject read FAutoCreateObject write SetFAutoCreateObject;
    property Cls : String read FCls write SetFCls;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property FieldClass : String read FFieldClass write SetFFieldClass;
    property FocusClass : String read FFocusClass write SetFFocusClass;
    property InputType : TExtFormFieldInputType read FInputType write SetFInputType;
    property InvalidClass : String read FInvalidClass write SetFInvalidClass;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property MsgFx : String read FMsgFx write SetFMsgFx;
    property MsgTarget : String read FMsgTarget write SetFMsgTarget;
    property Name : String read FName write SetFName;
    property PreventMark : Boolean read FPreventMark write SetFPreventMark;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
    property SubmitValue : Boolean read FSubmitValue write SetFSubmitValue;
    property TabIndex : Integer read FTabIndex write SetFTabIndex;
    property ValidateOnBlur : Boolean read FValidateOnBlur write SetFValidateOnBlur;
    property ValidationDelay : Integer read FValidationDelay write SetFValidationDelay;
    property ValidationEvent : String read FValidationEvent write SetFValidationEvent;
    property ValidationEventBoolean : Boolean read FValidationEventBoolean write SetFValidationEventBoolean;
    property Value : String read FValue write SetFValue;
    property LabelJS : TExtElement read FLabelJS write SetFLabelJS;
    property OriginalValue : String read FOriginalValue write SetFOriginalValue;
    property StartValue : String read FStartValue write SetFStartValue;
    property OnBlur : TExtFormFieldOnBlur read FOnBlur write SetFOnBlur;
    property OnChange : TExtFormFieldOnChange read FOnChange write SetFOnChange;
    property OnFocus : TExtFormFieldOnFocus read FOnFocus write SetFOnFocus;
    property OnInvalid : TExtFormFieldOnInvalid read FOnInvalid write SetFOnInvalid;
    property OnSpecialkey : TExtFormFieldOnSpecialkey read FOnSpecialkey write SetFOnSpecialkey;
    property OnValid : TExtFormFieldOnValid read FOnValid write SetFOnValid;
  end;

  TExtFormLabel = class(TExtBoxComponent)
  private
    FForId : String;
    FHtml : String;
    FText : String;
    procedure SetFForId(Value : String);
    procedure SetFHtml(Value : String);
    procedure SetFText(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetText(Text : String; Encode : Boolean = false) : TExtFunction;
    property ForId : String read FForId write SetFForId;
    property Html : String read FHtml write SetFHtml;
    property Text : String read FText write SetFText;
  end;

  TExtFormHidden = class(TExtFormField)
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
  end;

  // Procedural types for events TExtFormHtmlEditor
  TExtFormHtmlEditorOnActivate = procedure(This : TExtFormHtmlEditor) of object;
  TExtFormHtmlEditorOnBeforepush = procedure(This : TExtFormHtmlEditor; Html : String) of object;
  TExtFormHtmlEditorOnBeforesync = procedure(This : TExtFormHtmlEditor; Html : String) of object;
  TExtFormHtmlEditorOnEditmodechange = procedure(This : TExtFormHtmlEditor; SourceEdit : Boolean) of object;
  TExtFormHtmlEditorOnInitialize = procedure(This : TExtFormHtmlEditor) of object;
  TExtFormHtmlEditorOnPush = procedure(This : TExtFormHtmlEditor; Html : String) of object;
  TExtFormHtmlEditorOnSync = procedure(This : TExtFormHtmlEditor; Html : String) of object;

  TExtFormHtmlEditor = class(TExtFormField)
  private
    FCreateLinkText : String;
    FDefaultLinkValue : String;
    FDefaultValue : String;
    FEnableAlignments : Boolean; // true
    FEnableColors : Boolean; // true
    FEnableFont : Boolean; // true
    FEnableFontSize : Boolean; // true
    FEnableFormat : Boolean; // true
    FEnableLinks : Boolean; // true
    FEnableLists : Boolean; // true
    FEnableSourceEdit : Boolean; // true
    FFontFamilies : TExtObjectList;
    FButtonTips : TExtObject;
    FOnActivate : TExtFormHtmlEditorOnActivate;
    FOnBeforepush : TExtFormHtmlEditorOnBeforepush;
    FOnBeforesync : TExtFormHtmlEditorOnBeforesync;
    FOnEditmodechange : TExtFormHtmlEditorOnEditmodechange;
    FOnInitialize : TExtFormHtmlEditorOnInitialize;
    FOnPush : TExtFormHtmlEditorOnPush;
    FOnSync : TExtFormHtmlEditorOnSync;
    procedure SetFCreateLinkText(Value : String);
    procedure SetFDefaultLinkValue(Value : String);
    procedure SetFDefaultValue(Value : String);
    procedure SetFEnableAlignments(Value : Boolean);
    procedure SetFEnableColors(Value : Boolean);
    procedure SetFEnableFont(Value : Boolean);
    procedure SetFEnableFontSize(Value : Boolean);
    procedure SetFEnableFormat(Value : Boolean);
    procedure SetFEnableLinks(Value : Boolean);
    procedure SetFEnableLists(Value : Boolean);
    procedure SetFEnableSourceEdit(Value : Boolean);
    procedure SetFFontFamilies(Value : TExtObjectList);
    procedure SetFButtonTips(Value : TExtObject);
    procedure SetFOnActivate(Value : TExtFormHtmlEditorOnActivate);
    procedure SetFOnBeforepush(Value : TExtFormHtmlEditorOnBeforepush);
    procedure SetFOnBeforesync(Value : TExtFormHtmlEditorOnBeforesync);
    procedure SetFOnEditmodechange(Value : TExtFormHtmlEditorOnEditmodechange);
    procedure SetFOnInitialize(Value : TExtFormHtmlEditorOnInitialize);
    procedure SetFOnPush(Value : TExtFormHtmlEditorOnPush);
    procedure SetFOnSync(Value : TExtFormHtmlEditorOnSync);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function CleanHtml(Html : String) : TExtFunction;
    function ExecCmd(Cmd : String; Value : String = '') : TExtFunction; overload;
    function ExecCmd(Cmd : String; Value : Boolean) : TExtFunction; overload;
    function GetDocMarkup : TExtFunction;
    function GetToolbar : TExtFunction;
    function InsertAtCursor(Text : String) : TExtFunction;
    function PushValue : TExtFunction;
    function RelayCmd(Cmd : String; Value : String = '') : TExtFunction; overload;
    function RelayCmd(Cmd : String; Value : Boolean) : TExtFunction; overload;
    function SyncValue : TExtFunction;
    function ToggleSourceEdit(SourceEdit : Boolean = false) : TExtFunction;
    function UpdateToolbar : TExtFunction;
    destructor Destroy; override;
    property CreateLinkText : String read FCreateLinkText write SetFCreateLinkText;
    property DefaultLinkValue : String read FDefaultLinkValue write SetFDefaultLinkValue;
    property DefaultValue : String read FDefaultValue write SetFDefaultValue;
    property EnableAlignments : Boolean read FEnableAlignments write SetFEnableAlignments;
    property EnableColors : Boolean read FEnableColors write SetFEnableColors;
    property EnableFont : Boolean read FEnableFont write SetFEnableFont;
    property EnableFontSize : Boolean read FEnableFontSize write SetFEnableFontSize;
    property EnableFormat : Boolean read FEnableFormat write SetFEnableFormat;
    property EnableLinks : Boolean read FEnableLinks write SetFEnableLinks;
    property EnableLists : Boolean read FEnableLists write SetFEnableLists;
    property EnableSourceEdit : Boolean read FEnableSourceEdit write SetFEnableSourceEdit;
    property FontFamilies : TExtObjectList read FFontFamilies write SetFFontFamilies;
    property ButtonTips : TExtObject read FButtonTips write SetFButtonTips;
    property OnActivate : TExtFormHtmlEditorOnActivate read FOnActivate write SetFOnActivate;
    property OnBeforepush : TExtFormHtmlEditorOnBeforepush read FOnBeforepush write SetFOnBeforepush;
    property OnBeforesync : TExtFormHtmlEditorOnBeforesync read FOnBeforesync write SetFOnBeforesync;
    property OnEditmodechange : TExtFormHtmlEditorOnEditmodechange read FOnEditmodechange write SetFOnEditmodechange;
    property OnInitialize : TExtFormHtmlEditorOnInitialize read FOnInitialize write SetFOnInitialize;
    property OnPush : TExtFormHtmlEditorOnPush read FOnPush write SetFOnPush;
    property OnSync : TExtFormHtmlEditorOnSync read FOnSync write SetFOnSync;
  end;

  TExtUxCodePress = class(TExtFormField)
  private
    FAutoComplete : Boolean; // true
    FAutoResize : Boolean; // true
    FCode : String;
    FHeight : Integer;
    FLanguage : String; // 'pascal'
    FLineNumbers : Boolean; // true
    FPath : String;
    FReadOnly : Boolean;
    FSourceEl : String;
    FTrim : Boolean; // true
    FUrl : String;
    FWidth : Integer;
    procedure SetFAutoComplete(Value : Boolean);
    procedure SetFAutoResize(Value : Boolean);
    procedure SetFCode(Value : String);
    procedure SetFHeight(Value : Integer);
    procedure SetFLanguage(Value : String);
    procedure SetFLineNumbers(Value : Boolean);
    procedure SetFPath(Value : String);
    procedure SetFReadOnly(Value : Boolean);
    procedure SetFSourceEl(Value : String);
    procedure SetFTrim(Value : Boolean);
    procedure SetFUrl(Value : String);
    procedure SetFWidth(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Edit(Obj : TExtObject; Language : String) : TExtFunction;
    function SetCode(Code : String) : TExtFunction;
    function GetCode : TExtFunction;
    function GetLanguage : TExtFunction;
    function SetValue(Code : String) : TExtFunction;
    function GetValue : TExtFunction;
    function Resize : TExtFunction;
    function ToggleAutoComplete : TExtFunction;
    function ToggleReadOnly : TExtFunction;
    function ToggleLineNumbers : TExtFunction;
    function ToggleEditor : TExtFunction;
    property AutoComplete : Boolean read FAutoComplete write SetFAutoComplete;
    property AutoResize : Boolean read FAutoResize write SetFAutoResize;
    property Code : String read FCode write SetFCode;
    property Height : Integer read FHeight write SetFHeight;
    property Language : String read FLanguage write SetFLanguage;
    property LineNumbers : Boolean read FLineNumbers write SetFLineNumbers;
    property Path : String read FPath write SetFPath;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
    property SourceEl : String read FSourceEl write SetFSourceEl;
    property Trim : Boolean read FTrim write SetFTrim;
    property Url : String read FUrl write SetFUrl;
    property Width : Integer read FWidth write SetFWidth;
  end;

  // Procedural types for events TExtFormTextField
  TExtFormTextFieldOnAutosize = procedure(This : TExtFormTextField; Width : Integer) of object;
  TExtFormTextFieldOnKeydown = procedure(This : TExtFormTextField; E : TExtEventObjectSingleton) of object;
  TExtFormTextFieldOnKeypress = procedure(This : TExtFormTextField; E : TExtEventObjectSingleton) of object;
  TExtFormTextFieldOnKeyup = procedure(This : TExtFormTextField; E : TExtEventObjectSingleton) of object;

  TExtFormTextField = class(TExtFormField)
  private
    FAllowBlank : Boolean; // true
    FBlankText : String; // 'This field is required'
    FDisableKeyFilter : Boolean;
    FEmptyClass : String; // 'x-form-empty-field'
    FEmptyText : String;
    FEnableKeyEvents : Boolean;
    FGrow : Boolean;
    FGrowMax : Integer; // 800
    FGrowMin : Integer; // 30
    FMaskRe : TRegExp;
    FMaxLength : Integer;
    FMaxLengthText : String; // 'The maximum length for this field is {maxLength}'
    FMinLength : Integer; // 0
    FMinLengthText : String; // 'The minimum length for this field is {minLength}'
    FRegex : TRegExp;
    FRegexText : String;
    FSelectOnFocus : Boolean;
    FStripCharsRe : TRegExp;
    FValidator : TExtFunction;
    FVtype : String;
    FVtypeText : String;
    FOnAutosize : TExtFormTextFieldOnAutosize;
    FOnKeydown : TExtFormTextFieldOnKeydown;
    FOnKeypress : TExtFormTextFieldOnKeypress;
    FOnKeyup : TExtFormTextFieldOnKeyup;
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFBlankText(Value : String);
    procedure SetFDisableKeyFilter(Value : Boolean);
    procedure SetFEmptyClass(Value : String);
    procedure SetFEmptyText(Value : String);
    procedure SetFEnableKeyEvents(Value : Boolean);
    procedure SetFGrow(Value : Boolean);
    procedure SetFGrowMax(Value : Integer);
    procedure SetFGrowMin(Value : Integer);
    procedure SetFMaskRe(Value : TRegExp);
    procedure SetFMaxLength(Value : Integer);
    procedure SetFMaxLengthText(Value : String);
    procedure SetFMinLength(Value : Integer);
    procedure SetFMinLengthText(Value : String);
    procedure SetFRegex(Value : TRegExp);
    procedure SetFRegexText(Value : String);
    procedure SetFSelectOnFocus(Value : Boolean);
    procedure SetFStripCharsRe(Value : TRegExp);
    procedure SetFValidator(Value : TExtFunction);
    procedure SetFVtype(Value : String);
    procedure SetFVtypeText(Value : String);
    procedure SetFOnAutosize(Value : TExtFormTextFieldOnAutosize);
    procedure SetFOnKeydown(Value : TExtFormTextFieldOnKeydown);
    procedure SetFOnKeypress(Value : TExtFormTextFieldOnKeypress);
    procedure SetFOnKeyup(Value : TExtFormTextFieldOnKeyup);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function AutoSize : TExtFunction;
    function GetErrors(Value : String) : TExtFunction;
    function Reset : TExtFunction;
    function SelectText(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property BlankText : String read FBlankText write SetFBlankText;
    property DisableKeyFilter : Boolean read FDisableKeyFilter write SetFDisableKeyFilter;
    property EmptyClass : String read FEmptyClass write SetFEmptyClass;
    property EmptyText : String read FEmptyText write SetFEmptyText;
    property EnableKeyEvents : Boolean read FEnableKeyEvents write SetFEnableKeyEvents;
    property Grow : Boolean read FGrow write SetFGrow;
    property GrowMax : Integer read FGrowMax write SetFGrowMax;
    property GrowMin : Integer read FGrowMin write SetFGrowMin;
    property MaskRe : TRegExp read FMaskRe write SetFMaskRe;
    property MaxLength : Integer read FMaxLength write SetFMaxLength;
    property MaxLengthText : String read FMaxLengthText write SetFMaxLengthText;
    property MinLength : Integer read FMinLength write SetFMinLength;
    property MinLengthText : String read FMinLengthText write SetFMinLengthText;
    property Regex : TRegExp read FRegex write SetFRegex;
    property RegexText : String read FRegexText write SetFRegexText;
    property SelectOnFocus : Boolean read FSelectOnFocus write SetFSelectOnFocus;
    property StripCharsRe : TRegExp read FStripCharsRe write SetFStripCharsRe;
    property Validator : TExtFunction read FValidator write SetFValidator;
    property Vtype : String read FVtype write SetFVtype;
    property VtypeText : String read FVtypeText write SetFVtypeText;
    property OnAutosize : TExtFormTextFieldOnAutosize read FOnAutosize write SetFOnAutosize;
    property OnKeydown : TExtFormTextFieldOnKeydown read FOnKeydown write SetFOnKeydown;
    property OnKeypress : TExtFormTextFieldOnKeypress read FOnKeypress write SetFOnKeypress;
    property OnKeyup : TExtFormTextFieldOnKeyup read FOnKeyup write SetFOnKeyup;
  end;

  TExtFormSliderField = class(TExtFormField)
  private
    FTipText : TExtFunction;
    FUseTips : Boolean;
    procedure SetFTipText(Value : TExtFunction);
    procedure SetFUseTips(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetValue : TExtFunction;
    function SetMaxValue(V : Integer) : TExtFunction;
    function SetMinValue(V : Integer) : TExtFunction;
    function SetValue(V : Integer; Animate : Boolean = false) : TExtFunction;
    property TipText : TExtFunction read FTipText write SetFTipText;
    property UseTips : Boolean read FUseTips write SetFUseTips;
  end;

  TExtFormDisplayField = class(TExtFormField)
  private
    FFieldClass : String; // 'x-form-display-field'
    FHtmlEncode : Boolean;
    procedure SetFFieldClass(Value : String);
    procedure SetFHtmlEncode(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property FieldClass : String read FFieldClass write SetFFieldClass;
    property HtmlEncode : Boolean read FHtmlEncode write SetFHtmlEncode;
  end;

  TExtFormCompositeField = class(TExtFormField)
  private
    FY : Integer;
    FDefaultMargins : String;
    FFieldErrors : TExtObjectList;
    FInnerCt : TExtContainer;
    FIsComposite : Boolean;
    FItems : TExtObjectList;
    FRendered : Boolean; // true
    procedure SetFY(Value : Integer);
    procedure SetFDefaultMargins(Value : String);
    procedure SetFFieldErrors(Value : TExtObjectList);
    procedure SetFInnerCt(Value : TExtContainer);
    procedure SetFIsComposite(Value : Boolean);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFRendered(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function BuildCombinedErrorMessage(Errors : TExtObjectList) : TExtFunction;
    function BuildLabel(Segments : TExtObjectList) : TExtFunction;
    function ClearInvalidChildren : TExtFunction;
    function IsDirty : TExtFunction;
    function OnFieldClearInvalid(Field : TExtFormField) : TExtFunction;
    function OnFieldMarkInvalid(Field : TExtFormField; Message : String) : TExtFunction;
    function Reset : TExtFunction;
    function SortErrors : TExtFunction;
    function ValidateValue : TExtFunction;
    destructor Destroy; override;
    property Y : Integer read FY write SetFY;
    property DefaultMargins : String read FDefaultMargins write SetFDefaultMargins;
    property FieldErrors : TExtObjectList read FFieldErrors write SetFFieldErrors;
    property InnerCt : TExtContainer read FInnerCt write SetFInnerCt;
    property IsComposite : Boolean read FIsComposite write SetFIsComposite;
    property Items : TExtObjectList read FItems write SetFItems;
    property Rendered : Boolean read FRendered write SetFRendered;
  end;

  // Procedural types for events TExtFormCheckbox
  TExtFormCheckboxOnCheck = procedure(This : TExtFormCheckbox; Checked : Boolean) of object;

  TExtFormCheckbox = class(TExtFormField)
  private
    FAutoCreate : String; // 'input'
    FAutoCreateObject : TExtObject;
    FBoxLabel : String;
    FBoxLabel_ : String;
    FChecked : Boolean;
    FFieldClass : String; // 'x-form-field'
    FFocusClass : String;
    FHandler : TExtFunction;
    FInputValue : String;
    FScope : TExtObject;
    FOnCheck : TExtFormCheckboxOnCheck;
    procedure SetFAutoCreate(Value : String);
    procedure SetFAutoCreateObject(Value : TExtObject);
    procedure SetFBoxLabel(Value : String);
    procedure SetFBoxLabel_(Value : String);
    procedure SetFChecked(Value : Boolean);
    procedure SetFFieldClass(Value : String);
    procedure SetFFocusClass(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFInputValue(Value : String);
    procedure SetFScope(Value : TExtObject);
    procedure SetFOnCheck(Value : TExtFormCheckboxOnCheck);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetValue : TExtFunction;
    function SetValue(Checked : Boolean) : TExtFunction; overload;
    function SetValue(Checked : String) : TExtFunction; overload;
    destructor Destroy; override;
    property AutoCreate : String read FAutoCreate write SetFAutoCreate;
    property AutoCreateObject : TExtObject read FAutoCreateObject write SetFAutoCreateObject;
    property BoxLabel : String read FBoxLabel write SetFBoxLabel;
    property BoxLabel_ : String read FBoxLabel_ write SetFBoxLabel_;
    property Checked : Boolean read FChecked write SetFChecked;
    property FieldClass : String read FFieldClass write SetFFieldClass;
    property FocusClass : String read FFocusClass write SetFFocusClass;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property InputValue : String read FInputValue write SetFInputValue;
    property Scope : TExtObject read FScope write SetFScope;
    property OnCheck : TExtFormCheckboxOnCheck read FOnCheck write SetFOnCheck;
  end;

  // Procedural types for events TExtFormCheckboxGroup
  TExtFormCheckboxGroupOnChange = procedure(This : TExtFormCheckboxGroup; Checked : TExtObjectList) of object;

  TExtFormCheckboxGroup = class(TExtFormField)
  private
    FAllowBlank : Boolean; // true
    FBlankText : String; // 'You must select at least one item in this group'
    FColumns : String;
    FColumnsNumber : Integer;
    FColumnsArray : TExtObjectList;
    FItems : TExtObjectList;
    FVertical : Boolean;
    FOnChange : TExtFormCheckboxGroupOnChange;
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFBlankText(Value : String);
    procedure SetFColumns(Value : String);
    procedure SetFColumnsNumber(Value : Integer);
    procedure SetFColumnsArray(Value : TExtObjectList);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFVertical(Value : Boolean);
    procedure SetFOnChange(Value : TExtFormCheckboxGroupOnChange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetErrors : TExtFunction;
    function GetValue : TExtFunction;
    function SetValue(Id : String; Value : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property BlankText : String read FBlankText write SetFBlankText;
    property Columns : String read FColumns write SetFColumns;
    property ColumnsNumber : Integer read FColumnsNumber write SetFColumnsNumber;
    property ColumnsArray : TExtObjectList read FColumnsArray write SetFColumnsArray;
    property Items : TExtObjectList read FItems write SetFItems;
    property Vertical : Boolean read FVertical write SetFVertical;
    property OnChange : TExtFormCheckboxGroupOnChange read FOnChange write SetFOnChange;
  end;

  TExtFormTextArea = class(TExtFormTextField)
  private
    FAutoCreate : String;
    FAutoCreateObject : TExtObject;
    FGrowMax : Integer; // 1000
    FGrowMin : Integer; // 60
    FPreventScrollbars : Boolean;
    procedure SetFAutoCreate(Value : String);
    procedure SetFAutoCreateObject(Value : TExtObject);
    procedure SetFGrowMax(Value : Integer);
    procedure SetFGrowMin(Value : Integer);
    procedure SetFPreventScrollbars(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function AutoSize : TExtFunction;
    destructor Destroy; override;
    property AutoCreate : String read FAutoCreate write SetFAutoCreate;
    property AutoCreateObject : TExtObject read FAutoCreateObject write SetFAutoCreateObject;
    property GrowMax : Integer read FGrowMax write SetFGrowMax;
    property GrowMin : Integer read FGrowMin write SetFGrowMin;
    property PreventScrollbars : Boolean read FPreventScrollbars write SetFPreventScrollbars;
  end;

  TExtFormTriggerField = class(TExtFormTextField)
  private
    FAutoCreate : String;
    FAutoCreateObject : TExtObject;
    FEditable : Boolean; // true
    FHideTrigger : Boolean;
    FReadOnly : Boolean;
    FTriggerClass : String;
    FTriggerConfig : String;
    FWrapFocusClass : String;
    procedure SetFAutoCreate(Value : String);
    procedure SetFAutoCreateObject(Value : TExtObject);
    procedure SetFEditable(Value : Boolean);
    procedure SetFHideTrigger(Value : Boolean);
    procedure SetFReadOnly(Value : Boolean);
    procedure SetFTriggerClass(Value : String);
    procedure SetFTriggerConfig(Value : String);
    procedure SetFWrapFocusClass(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function OnTriggerClick(E : TEventObject) : TExtFunction;
    function SetEditable(Value : Boolean) : TExtFunction;
    function SetReadOnly(Value : Boolean) : TExtFunction;
    destructor Destroy; override;
    property AutoCreate : String read FAutoCreate write SetFAutoCreate;
    property AutoCreateObject : TExtObject read FAutoCreateObject write SetFAutoCreateObject;
    property Editable : Boolean read FEditable write SetFEditable;
    property HideTrigger : Boolean read FHideTrigger write SetFHideTrigger;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
    property TriggerClass : String read FTriggerClass write SetFTriggerClass;
    property TriggerConfig : String read FTriggerConfig write SetFTriggerConfig;
    property WrapFocusClass : String read FWrapFocusClass write SetFWrapFocusClass;
  end;

  TExtFormNumberField = class(TExtFormTextField)
  private
    FAllowDecimals : Boolean; // true
    FAllowNegative : Boolean; // true
    FBaseChars : String; // '0123456789'
    FDecimalPrecision : Integer; // 2
    FDecimalSeparator : String; // '.'
    FFieldClass : String; // 'x-form-field x-form-num-field'
    FMaxText : String; // 'The maximum value for this field is {maxValue}'
    FMaxValue : Integer;
    FMinText : String; // 'The minimum value for this field is {minValue}'
    FMinValue : Integer;
    FNanText : String; // '{value} is not a valid number'
    procedure SetFAllowDecimals(Value : Boolean);
    procedure SetFAllowNegative(Value : Boolean);
    procedure SetFBaseChars(Value : String);
    procedure SetFDecimalPrecision(Value : Integer);
    procedure SetFDecimalSeparator(Value : String);
    procedure SetFFieldClass(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFMaxValue(Value : Integer);
    procedure SetFMinText(Value : String);
    procedure SetFMinValue(Value : Integer);
    procedure SetFNanText(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetErrors(Value : String) : TExtFunction;
    function SetMaxValue(Value : Integer) : TExtFunction;
    function SetMinValue(Value : Integer) : TExtFunction;
    property AllowDecimals : Boolean read FAllowDecimals write SetFAllowDecimals;
    property AllowNegative : Boolean read FAllowNegative write SetFAllowNegative;
    property BaseChars : String read FBaseChars write SetFBaseChars;
    property DecimalPrecision : Integer read FDecimalPrecision write SetFDecimalPrecision;
    property DecimalSeparator : String read FDecimalSeparator write SetFDecimalSeparator;
    property FieldClass : String read FFieldClass write SetFFieldClass;
    property MaxText : String read FMaxText write SetFMaxText;
    property MaxValue : Integer read FMaxValue write SetFMaxValue;
    property MinText : String read FMinText write SetFMinText;
    property MinValue : Integer read FMinValue write SetFMinValue;
    property NanText : String read FNanText write SetFNanText;
  end;

  TExtFormFieldSet = class(TExtPanel)
  private
    FAnimCollapse : Boolean;
    FBaseCls : String; // 'x-fieldset'
    FCheckboxName : String; // '[checkbox id]-checkbox'
    FCheckboxToggle : String;
    FCollapsible : Boolean;
    FItemCls : String;
    FLabelWidth : Integer;
    FLayout : String; // 'form'
    procedure SetFAnimCollapse(Value : Boolean);
    procedure SetFBaseCls(Value : String);
    procedure SetFCheckboxName(Value : String);
    procedure SetFCheckboxToggle(Value : String);
    procedure SetFCollapsible(Value : Boolean);
    procedure SetFItemCls(Value : String);
    procedure SetFLabelWidth(Value : Integer);
    procedure SetFLayout(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function OnCheckClick : TExtFunction;
    property AnimCollapse : Boolean read FAnimCollapse write SetFAnimCollapse;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property CheckboxName : String read FCheckboxName write SetFCheckboxName;
    property CheckboxToggle : String read FCheckboxToggle write SetFCheckboxToggle;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
    property ItemCls : String read FItemCls write SetFItemCls;
    property LabelWidth : Integer read FLabelWidth write SetFLabelWidth;
    property Layout : String read FLayout write SetFLayout;
  end;

  // Procedural types for events TExtFormFormPanel
  TExtFormFormPanelOnClientvalidation = procedure(This : TExtFormFormPanel; Valid : Boolean) of object;

  // Enumerated types for properties
  TExtFormFormPanelLabelAlign = (laLeft, laTop, laRight);

  TExtFormFormPanel = class(TExtPanel)
  private
    FButtons : TExtObjectList;
    FForm : TExtFormBasicForm;
    FFormId : String;
    FHideLabels : Boolean;
    FItemCls : String;
    FLabelAlign : TExtFormFormPanelLabelAlign; // 'left'
    FLabelPad : Integer; // 5
    FLabelSeparator : String;
    FLabelWidth : Integer; // 100
    FLayout : String;
    FMinButtonWidth : Integer; // 75
    FMonitorPoll : Integer; // 200
    FMonitorValid : Boolean;
    FFileUpload : Boolean;
    FOnClientvalidation : TExtFormFormPanelOnClientvalidation;
    procedure SetFButtons(Value : TExtObjectList);
    procedure SetFFormId(Value : String);
    procedure SetFHideLabels(Value : Boolean);
    procedure SetFItemCls(Value : String);
    procedure SetFLabelAlign(Value : TExtFormFormPanelLabelAlign);
    procedure SetFLabelPad(Value : Integer);
    procedure SetFLabelSeparator(Value : String);
    procedure SetFLabelWidth(Value : Integer);
    procedure SetFLayout(Value : String);
    procedure SetFMinButtonWidth(Value : Integer);
    procedure SetFMonitorPoll(Value : Integer);
    procedure SetFMonitorValid(Value : Boolean);
    procedure SetFFileUpload(Value : Boolean);
    procedure SetFOnClientvalidation(Value : TExtFormFormPanelOnClientvalidation);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetForm : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction;
    function StartMonitoring : TExtFunction;
    function StopMonitoring : TExtFunction;
    destructor Destroy; override;
    property Buttons : TExtObjectList read FButtons write SetFButtons;
    property Form : TExtFormBasicForm read FForm;
    property FormId : String read FFormId write SetFFormId;
    property HideLabels : Boolean read FHideLabels write SetFHideLabels;
    property ItemCls : String read FItemCls write SetFItemCls;
    property LabelAlign : TExtFormFormPanelLabelAlign read FLabelAlign write SetFLabelAlign;
    property LabelPad : Integer read FLabelPad write SetFLabelPad;
    property LabelSeparator : String read FLabelSeparator write SetFLabelSeparator;
    property LabelWidth : Integer read FLabelWidth write SetFLabelWidth;
    property Layout : String read FLayout write SetFLayout;
    property MinButtonWidth : Integer read FMinButtonWidth write SetFMinButtonWidth;
    property MonitorPoll : Integer read FMonitorPoll write SetFMonitorPoll;
    property MonitorValid : Boolean read FMonitorValid write SetFMonitorValid;
    property FileUpload : Boolean read FFileUpload write SetFFileUpload;
    property OnClientvalidation : TExtFormFormPanelOnClientvalidation read FOnClientvalidation write SetFOnClientvalidation;
  end;

  // Procedural types for events TExtFormRadioGroup
  TExtFormRadioGroupOnChange = procedure(This : TExtFormRadioGroup; Checked : TExtFormRadio) of object;

  TExtFormRadioGroup = class(TExtFormCheckboxGroup)
  private
    FAllowBlank : Boolean; // true
    FBlankText : String; // 'You must select one item in this group'
    FItems : TExtObjectList;
    FOnChange : TExtFormRadioGroupOnChange;
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFBlankText(Value : String);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFOnChange(Value : TExtFormRadioGroupOnChange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetValue : TExtFunction;
    function OnSetValue(Id : String; Value : Boolean) : TExtFunction; overload;
    function OnSetValue(Id : TExtFormRadio; Value : Boolean) : TExtFunction; overload;
    destructor Destroy; override;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property BlankText : String read FBlankText write SetFBlankText;
    property Items : TExtObjectList read FItems write SetFItems;
    property OnChange : TExtFormRadioGroupOnChange read FOnChange write SetFOnChange;
  end;

  TExtFormRadio = class(TExtFormCheckbox)
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetGroupValue : TExtFunction;
    function SetValue(Value : String) : TExtFunction; overload;
    function SetValue(Value : Boolean) : TExtFunction; overload;
  end;

  // Procedural types for events TExtFormDateField
  TExtFormDateFieldOnSelect = procedure(This : TExtFormDateField; Date : TDateTime) of object;

  TExtFormDateField = class(TExtFormTriggerField)
  private
    FAltFormats : String; // 'm/d/Y/n/j/Y/n/j/y/m/j/y/n/d/y/m/j/Y/n/d/Y/m-d-y/m-d-Y/m/d/m-d/md/mdy/mdY/d/Y-m-d'
    FAutoCreate : String;
    FAutoCreateObject : TExtObject;
    FDisabledDates : TExtObjectList;
    FDisabledDatesText : String; // 'Disabled'
    FDisabledDays : TExtObjectList;
    FDisabledDaysText : String; // 'Disabled'
    FFormat : String; // 'm/d/Y'
    FInvalidText : String; // '{value} is not a valid date - it must be in the format {format}'
    FMaxText : String; // 'The date in this field must be before {maxValue}'
    FMaxValue : TDateTime;
    FMaxValueString : String;
    FMinText : String; // 'The date in this field must be after {minValue}'
    FMinValue : TDateTime;
    FMinValueString : String;
    FShowToday : Boolean; // true
    FTriggerClass : String; // 'x-form-date-trigger'
    FOnSelect : TExtFormDateFieldOnSelect;
    procedure SetFAltFormats(Value : String);
    procedure SetFAutoCreate(Value : String);
    procedure SetFAutoCreateObject(Value : TExtObject);
    procedure SetFDisabledDates(Value : TExtObjectList);
    procedure SetFDisabledDatesText(Value : String);
    procedure SetFDisabledDays(Value : TExtObjectList);
    procedure SetFDisabledDaysText(Value : String);
    procedure SetFFormat(Value : String);
    procedure SetFInvalidText(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFMaxValue(Value : TDateTime);
    procedure SetFMaxValueString(Value : String);
    procedure SetFMinText(Value : String);
    procedure SetFMinValue(Value : TDateTime);
    procedure SetFMinValueString(Value : String);
    procedure SetFShowToday(Value : Boolean);
    procedure SetFTriggerClass(Value : String);
    procedure SetFOnSelect(Value : TExtFormDateFieldOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetErrors(Value : String) : TExtFunction;
    function GetValue : TExtFunction;
    function SetDisabledDates(DisabledDates : TExtObjectList) : TExtFunction;
    function SetDisabledDays(DisabledDays : TExtObjectList) : TExtFunction;
    function SetMaxValue(Value : TDateTime) : TExtFunction;
    function SetMinValue(Value : TDateTime) : TExtFunction;
    function SetValue(Date : String) : TExtFunction; overload;
    function SetValue(Date : TDateTime) : TExtFunction; overload;
    destructor Destroy; override;
    property AltFormats : String read FAltFormats write SetFAltFormats;
    property AutoCreate : String read FAutoCreate write SetFAutoCreate;
    property AutoCreateObject : TExtObject read FAutoCreateObject write SetFAutoCreateObject;
    property DisabledDates : TExtObjectList read FDisabledDates write SetFDisabledDates;
    property DisabledDatesText : String read FDisabledDatesText write SetFDisabledDatesText;
    property DisabledDays : TExtObjectList read FDisabledDays write SetFDisabledDays;
    property DisabledDaysText : String read FDisabledDaysText write SetFDisabledDaysText;
    property Format : String read FFormat write SetFFormat;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property MaxText : String read FMaxText write SetFMaxText;
    property MaxValue : TDateTime read FMaxValue write SetFMaxValue;
    property MaxValueString : String read FMaxValueString write SetFMaxValueString;
    property MinText : String read FMinText write SetFMinText;
    property MinValue : TDateTime read FMinValue write SetFMinValue;
    property MinValueString : String read FMinValueString write SetFMinValueString;
    property ShowToday : Boolean read FShowToday write SetFShowToday;
    property TriggerClass : String read FTriggerClass write SetFTriggerClass;
    property OnSelect : TExtFormDateFieldOnSelect read FOnSelect write SetFOnSelect;
  end;

  // Procedural types for events TExtFormComboBox
  TExtFormComboBoxOnBeforequery = procedure(QueryEvent : TExtObject) of object;
  TExtFormComboBoxOnBeforeselect = procedure(Combo : TExtFormComboBox; RecordJS : TExtDataRecord; Index : Integer) of object;
  TExtFormComboBoxOnCollapse = procedure(Combo : TExtFormComboBox) of object;
  TExtFormComboBoxOnExpand = procedure(Combo : TExtFormComboBox) of object;
  TExtFormComboBoxOnSelect = procedure(Combo : TExtFormComboBox; RecordJS : TExtDataRecord; Index : Integer) of object;

  TExtFormComboBox = class(TExtFormTriggerField)
  private
    FAllQuery : String;
    FAutoCreate : String;
    FAutoCreateObject : TExtObject;
    FAutoSelect : Boolean; // true
    FClearFilterOnReset : Boolean; // true
    FDisplayField : String; // 'output/Ext.form.ComboBox.html#Ext.form.ComboBox-mode'
    FForceSelection : Boolean;
    FHandleHeight : Integer; // 8
    FHiddenId : String; // 'output/Ext.form.ComboBox.html#Ext.form.ComboBox-hiddenName'
    FHiddenName : String;
    FHiddenValue : String;
    FItemSelector : String;
    FLazyInit : Boolean; // true
    FLazyRender : Boolean;
    FListAlign : String; // 'tl-bl?'
    FListAlignArray : TExtObjectList;
    FListClass : String;
    FListEmptyText : String;
    FListWidth : Integer;
    FLoadingText : String; // 'Loading...'
    FMaxHeight : Integer; // 300
    FMinChars : Integer; // 4
    FMinHeight : Integer; // 90
    FMinListWidth : Integer; // 70
    FMode : String;
    FPageSize : Integer; // 0
    FQueryDelay : Integer; // 500
    FQueryParam : String; // 'query'
    FResizable : Boolean;
    FSelectOnFocus : Boolean; // true
    FSelectedClass : String; // 'x-combo-selected'
    FShadow : Boolean;
    FShadowString : String;
    FStore : TExtDataStore;
    FStoreArray : TExtObjectList;
    FSubmitValue : Boolean;
    FTitle : String;
    FTpl : String;
    FTplExtXTemplate : TExtXTemplate;
    FTransform : String;
    FTriggerAction : String;
    FTriggerClass : String; // 'x-form-arrow-trigger'
    FTypeAhead : Boolean;
    FTypeAheadDelay : Integer; // 250
    FValueField : String; // 'output/Ext.form.ComboBox.html#Ext.form.ComboBox-mode'
    FValueNotFoundText : String;
    FKeyNav : TExtKeyNav;
    FLastQuery : String;
    FView : TExtDataView;
    FOnBeforequery : TExtFormComboBoxOnBeforequery;
    FOnBeforeselect : TExtFormComboBoxOnBeforeselect;
    FOnCollapse : TExtFormComboBoxOnCollapse;
    FOnExpand : TExtFormComboBoxOnExpand;
    FOnSelect : TExtFormComboBoxOnSelect;
    procedure SetFAllQuery(Value : String);
    procedure SetFAutoCreate(Value : String);
    procedure SetFAutoCreateObject(Value : TExtObject);
    procedure SetFAutoSelect(Value : Boolean);
    procedure SetFClearFilterOnReset(Value : Boolean);
    procedure SetFDisplayField(Value : String);
    procedure SetFForceSelection(Value : Boolean);
    procedure SetFHandleHeight(Value : Integer);
    procedure SetFHiddenId(Value : String);
    procedure SetFHiddenName(Value : String);
    procedure SetFHiddenValue(Value : String);
    procedure SetFItemSelector(Value : String);
    procedure SetFLazyInit(Value : Boolean);
    procedure SetFLazyRender(Value : Boolean);
    procedure SetFListAlign(Value : String);
    procedure SetFListAlignArray(Value : TExtObjectList);
    procedure SetFListClass(Value : String);
    procedure SetFListEmptyText(Value : String);
    procedure SetFListWidth(Value : Integer);
    procedure SetFLoadingText(Value : String);
    procedure SetFMaxHeight(Value : Integer);
    procedure SetFMinChars(Value : Integer);
    procedure SetFMinHeight(Value : Integer);
    procedure SetFMinListWidth(Value : Integer);
    procedure SetFMode(Value : String);
    procedure SetFPageSize(Value : Integer);
    procedure SetFQueryDelay(Value : Integer);
    procedure SetFQueryParam(Value : String);
    procedure SetFResizable(Value : Boolean);
    procedure SetFSelectOnFocus(Value : Boolean);
    procedure SetFSelectedClass(Value : String);
    procedure SetFShadow(Value : Boolean);
    procedure SetFShadowString(Value : String);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFStoreArray(Value : TExtObjectList);
    procedure SetFSubmitValue(Value : Boolean);
    procedure SetFTitle(Value : String);
    procedure SetFTpl(Value : String);
    procedure SetFTplExtXTemplate(Value : TExtXTemplate);
    procedure SetFTransform(Value : String);
    procedure SetFTriggerAction(Value : String);
    procedure SetFTriggerClass(Value : String);
    procedure SetFTypeAhead(Value : Boolean);
    procedure SetFTypeAheadDelay(Value : Integer);
    procedure SetFValueField(Value : String);
    procedure SetFValueNotFoundText(Value : String);
    procedure SetFKeyNav(Value : TExtKeyNav);
    procedure SetFLastQuery(Value : String);
    procedure SetFView(Value : TExtDataView);
    procedure SetFOnBeforequery(Value : TExtFormComboBoxOnBeforequery);
    procedure SetFOnBeforeselect(Value : TExtFormComboBoxOnBeforeselect);
    procedure SetFOnCollapse(Value : TExtFormComboBoxOnCollapse);
    procedure SetFOnExpand(Value : TExtFormComboBoxOnExpand);
    procedure SetFOnSelect(Value : TExtFormComboBoxOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(const AForcedJSName: string = '');
    function ClearValue : TExtFunction;
    function Collapse : TExtFunction;
    function DoQuery(Query : String; ForceAll : Boolean) : TExtFunction;
    function Expand : TExtFunction;
    function GetListParent : TExtFunction;
    function GetStore : TExtFunction;
    function GetValue : TExtFunction;
    function IsExpanded : TExtFunction;
    function Select(Index : Integer; ScrollIntoView : Boolean) : TExtFunction;
    function SelectByValue(Value : String; ScrollIntoView : Boolean) : TExtFunction;
    function SetValue(Value : String) : TExtFunction;
    destructor Destroy; override;
    property AllQuery : String read FAllQuery write SetFAllQuery;
    property AutoCreate : String read FAutoCreate write SetFAutoCreate;
    property AutoCreateObject : TExtObject read FAutoCreateObject write SetFAutoCreateObject;
    property AutoSelect : Boolean read FAutoSelect write SetFAutoSelect;
    property ClearFilterOnReset : Boolean read FClearFilterOnReset write SetFClearFilterOnReset;
    property DisplayField : String read FDisplayField write SetFDisplayField;
    property ForceSelection : Boolean read FForceSelection write SetFForceSelection;
    property HandleHeight : Integer read FHandleHeight write SetFHandleHeight;
    property HiddenId : String read FHiddenId write SetFHiddenId;
    property HiddenName : String read FHiddenName write SetFHiddenName;
    property HiddenValue : String read FHiddenValue write SetFHiddenValue;
    property ItemSelector : String read FItemSelector write SetFItemSelector;
    property LazyInit : Boolean read FLazyInit write SetFLazyInit;
    property LazyRender : Boolean read FLazyRender write SetFLazyRender;
    property ListAlign : String read FListAlign write SetFListAlign;
    property ListAlignArray : TExtObjectList read FListAlignArray write SetFListAlignArray;
    property ListClass : String read FListClass write SetFListClass;
    property ListEmptyText : String read FListEmptyText write SetFListEmptyText;
    property ListWidth : Integer read FListWidth write SetFListWidth;
    property LoadingText : String read FLoadingText write SetFLoadingText;
    property MaxHeight : Integer read FMaxHeight write SetFMaxHeight;
    property MinChars : Integer read FMinChars write SetFMinChars;
    property MinHeight : Integer read FMinHeight write SetFMinHeight;
    property MinListWidth : Integer read FMinListWidth write SetFMinListWidth;
    property Mode : String read FMode write SetFMode;
    property PageSize : Integer read FPageSize write SetFPageSize;
    property QueryDelay : Integer read FQueryDelay write SetFQueryDelay;
    property QueryParam : String read FQueryParam write SetFQueryParam;
    property Resizable : Boolean read FResizable write SetFResizable;
    property SelectOnFocus : Boolean read FSelectOnFocus write SetFSelectOnFocus;
    property SelectedClass : String read FSelectedClass write SetFSelectedClass;
    property Shadow : Boolean read FShadow write SetFShadow;
    property ShadowString : String read FShadowString write SetFShadowString;
    property Store : TExtDataStore read FStore write SetFStore;
    property StoreArray : TExtObjectList read FStoreArray write SetFStoreArray;
    property SubmitValue : Boolean read FSubmitValue write SetFSubmitValue;
    property Title : String read FTitle write SetFTitle;
    property Tpl : String read FTpl write SetFTpl;
    property TplExtXTemplate : TExtXTemplate read FTplExtXTemplate write SetFTplExtXTemplate;
    property Transform : String read FTransform write SetFTransform;
    property TriggerAction : String read FTriggerAction write SetFTriggerAction;
    property TriggerClass : String read FTriggerClass write SetFTriggerClass;
    property TypeAhead : Boolean read FTypeAhead write SetFTypeAhead;
    property TypeAheadDelay : Integer read FTypeAheadDelay write SetFTypeAheadDelay;
    property ValueField : String read FValueField write SetFValueField;
    property ValueNotFoundText : String read FValueNotFoundText write SetFValueNotFoundText;
    property KeyNav : TExtKeyNav read FKeyNav write SetFKeyNav;
    property LastQuery : String read FLastQuery write SetFLastQuery;
    property View : TExtDataView read FView write SetFView;
    property OnBeforequery : TExtFormComboBoxOnBeforequery read FOnBeforequery write SetFOnBeforequery;
    property OnBeforeselect : TExtFormComboBoxOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnCollapse : TExtFormComboBoxOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnExpand : TExtFormComboBoxOnExpand read FOnExpand write SetFOnExpand;
    property OnSelect : TExtFormComboBoxOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtFormTwinTriggerField = class(TExtFormTriggerField)
  private
    FTrigger1Class : String;
    FTrigger2Class : String;
    FTriggerConfig : String;
    procedure SetFTrigger1Class(Value : String);
    procedure SetFTrigger2Class(Value : String);
    procedure SetFTriggerConfig(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function OnTrigger1Click(E : TEventObject) : TExtFunction;
    function OnTrigger2Click(E : TEventObject) : TExtFunction;
    property Trigger1Class : String read FTrigger1Class write SetFTrigger1Class;
    property Trigger2Class : String read FTrigger2Class write SetFTrigger2Class;
    property TriggerConfig : String read FTriggerConfig write SetFTriggerConfig;
  end;

  TExtFormTimeField = class(TExtFormComboBox)
  private
    FAltFormats : String; // 'g:ia/g:iA/g:i a/g:i A/h:i/g:i/H:i/ga/ha/gA/h a/g a/g A/gi/hi/gia/hia/g/H/gi a/hi a/giA/hiA/gi A/hi A'
    FFormat : String; // 'g:i A'
    FIncrement : Integer; // 15
    FInvalidText : String; // '{value} is not a valid time'
    FMaxText : String; // 'The time in this field must be equal to or before {0}'
    FMaxValue : TDateTime;
    FMaxValueString : String;
    FMinText : String; // 'The time in this field must be equal to or after {0}'
    FMinValue : TDateTime;
    FMinValueString : String;
    procedure SetFAltFormats(Value : String);
    procedure SetFFormat(Value : String);
    procedure SetFIncrement(Value : Integer);
    procedure SetFInvalidText(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFMaxValue(Value : TDateTime);
    procedure SetFMaxValueString(Value : String);
    procedure SetFMinText(Value : String);
    procedure SetFMinValue(Value : TDateTime);
    procedure SetFMinValueString(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetMaxValue(Value : TDateTime) : TExtFunction; overload;
    function SetMaxValue(Value : String) : TExtFunction; overload;
    function SetMinValue(Value : TDateTime) : TExtFunction; overload;
    function SetMinValue(Value : String) : TExtFunction; overload;
    property AltFormats : String read FAltFormats write SetFAltFormats;
    property Format : String read FFormat write SetFFormat;
    property Increment : Integer read FIncrement write SetFIncrement;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property MaxText : String read FMaxText write SetFMaxText;
    property MaxValue : TDateTime read FMaxValue write SetFMaxValue;
    property MaxValueString : String read FMaxValueString write SetFMaxValueString;
    property MinText : String read FMinText write SetFMinText;
    property MinValue : TDateTime read FMinValue write SetFMinValue;
    property MinValueString : String read FMinValueString write SetFMinValueString;
  end;

  TExtUxFormLovCombo = class(TExtFormComboBox)
  private
    FSeparator : String;
    procedure SetFSeparator(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Separator : String read FSeparator write SetFSeparator;
  end;

var
  ExtFormVTypes : TExtFormVTypesSingleton;

implementation

procedure TExtFormAction.SetFFailure(Value : TExtFunction); begin
  FFailure := Value;
  JSCode('failure:' + VarToJSON([Value, true]));
end;

procedure TExtFormAction.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFParams(Value : String); begin
  FParams := Value;
  JSCode('params:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFReset(Value : Boolean); begin
  FReset := Value;
  JSCode('reset:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFSubmitEmptyText(Value : Boolean); begin
  FSubmitEmptyText := Value;
  JSCode('submitEmptyText:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFSuccess(Value : TExtFunction); begin
  FSuccess := Value;
  JSCode('success:' + VarToJSON([Value, true]));
end;

procedure TExtFormAction.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFWaitMsg(Value : String); begin
  FWaitMsg := Value;
  JSCode('waitMsg:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFWaitTitle(Value : String); begin
  FWaitTitle := Value;
  JSCode('waitTitle:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFFailureType(Value : String); begin
  FFailureType := Value;
  JSCode(JSName + '.failureType=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormAction.SetFResponse(Value : TExtObject); begin
  FResponse := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.response=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormAction.SetFResultJS(Value : TExtObject); begin
  FResultJS := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.resultJS=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormAction.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode(JSName + '.typeJS=' + VarToJSON([Value]) + ';');
end;

function TExtFormAction.JSClassName : string; begin
  Result := '';
end;

class function TExtFormAction.CLIENT_INVALID : String; begin
  Result := ''
end;

class function TExtFormAction.CONNECT_FAILURE : String; begin
  Result := ''
end;

class function TExtFormAction.LOAD_FAILURE : String; begin
  Result := ''
end;

class function TExtFormAction.SERVER_INVALID : String; begin
  Result := ''
end;

{$IFDEF FPC}constructor TExtFormAction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormVTypesSingleton.SetFAlphaMask(Value : TRegExp); begin
  FAlphaMask := Value;
  JSCode(JSName + '.alphaMask=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtFormVTypesSingleton.SetFAlphaText(Value : String); begin
  FAlphaText := Value;
  JSCode(JSName + '.alphaText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormVTypesSingleton.SetFAlphanumMask(Value : TRegExp); begin
  FAlphanumMask := Value;
  JSCode(JSName + '.alphanumMask=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtFormVTypesSingleton.SetFAlphanumText(Value : String); begin
  FAlphanumText := Value;
  JSCode(JSName + '.alphanumText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormVTypesSingleton.SetFEmailMask(Value : TRegExp); begin
  FEmailMask := Value;
  JSCode(JSName + '.emailMask=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtFormVTypesSingleton.SetFEmailText(Value : String); begin
  FEmailText := Value;
  JSCode(JSName + '.emailText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormVTypesSingleton.SetFUrlText(Value : String); begin
  FUrlText := Value;
  JSCode(JSName + '.urlText=' + VarToJSON([Value]) + ';');
end;

function TExtFormVTypesSingleton.JSClassName : string; begin
  Result := 'Ext.form.VTypes';
end;

{$IFDEF FPC}constructor TExtFormVTypesSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormVTypesSingleton.Alpha(Value : String) : TExtFunction; begin
  JSCode(JSName + '.alpha(' + VarToJSON([Value]) + ');', 'TExtFormVTypesSingleton');
  Result := Self;
end;

function TExtFormVTypesSingleton.Alphanum(Value : String) : TExtFunction; begin
  JSCode(JSName + '.alphanum(' + VarToJSON([Value]) + ');', 'TExtFormVTypesSingleton');
  Result := Self;
end;

function TExtFormVTypesSingleton.Email(Value : String) : TExtFunction; begin
  JSCode(JSName + '.email(' + VarToJSON([Value]) + ');', 'TExtFormVTypesSingleton');
  Result := Self;
end;

function TExtFormVTypesSingleton.Url(Value : String) : TExtFunction; begin
  JSCode(JSName + '.url(' + VarToJSON([Value]) + ');', 'TExtFormVTypesSingleton');
  Result := Self;
end;

procedure TExtFormBasicForm.SetFApi(Value : TExtObject); begin
  FApi := Value;
  Value.DeleteFromGarbage;
  JSCode('api:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasicForm.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasicForm.SetFErrorReader(Value : TExtDataDataReader); begin
  FErrorReader := Value;
  Value.DeleteFromGarbage;
  JSCode('errorReader:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasicForm.SetFFileUpload(Value : Boolean); begin
  FFileUpload := Value;
  JSCode('fileUpload:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFParamOrder(Value : TExtObjectList); begin
  FParamOrder := Value;
  Value.DeleteFromGarbage;
  JSCode('paramOrder:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasicForm.SetFParamOrderString(Value : String); begin
  FParamOrderString := Value;
  JSCode('paramOrder:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFParamsAsHash(Value : Boolean); begin
  FParamsAsHash := Value;
  JSCode('paramsAsHash:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFReader(Value : TExtDataDataReader); begin
  FReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasicForm.SetFStandardSubmit(Value : Boolean); begin
  FStandardSubmit := Value;
  JSCode('standardSubmit:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFTrackResetOnLoad(Value : Boolean); begin
  FTrackResetOnLoad := Value;
  JSCode('trackResetOnLoad:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFWaitTitle(Value : String); begin
  FWaitTitle := Value;
  JSCode('waitTitle:' + VarToJSON([Value]));
end;

procedure TExtFormBasicForm.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.items=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormBasicForm.SetFWaitMsgTarget(Value : String); begin
  FWaitMsgTarget := Value;
  JSCode(JSName + '.waitMsgTarget=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormBasicForm.SetFOnActioncomplete(Value : TExtFormBasicFormOnActioncomplete); begin
  if Assigned(FOnActioncomplete) then
    JSCode(JSName+'.events ["actioncomplete"].listeners=[];');
  if Assigned(Value) then
    On('actioncomplete', Ajax('actioncomplete', ['This', '%0.nm','Action', '%1.nm'], true));
  FOnActioncomplete := Value;
end;

procedure TExtFormBasicForm.SetFOnActionfailed(Value : TExtFormBasicFormOnActionfailed); begin
  if Assigned(FOnActionfailed) then
    JSCode(JSName+'.events ["actionfailed"].listeners=[];');
  if Assigned(Value) then
    On('actionfailed', Ajax('actionfailed', ['This', '%0.nm','Action', '%1.nm'], true));
  FOnActionfailed := Value;
end;

procedure TExtFormBasicForm.SetFOnBeforeaction(Value : TExtFormBasicFormOnBeforeaction); begin
  if Assigned(FOnBeforeaction) then
    JSCode(JSName+'.events ["beforeaction"].listeners=[];');
  if Assigned(Value) then
    On('beforeaction', Ajax('beforeaction', ['This', '%0.nm','Action', '%1.nm'], true));
  FOnBeforeaction := Value;
end;

function TExtFormBasicForm.JSClassName : string; begin
  Result := 'Ext.form.BasicForm';
end;

procedure TExtFormBasicForm.InitDefaults; begin
  inherited;
  FApi := TExtObject.CreateInternal(Self, 'api');
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
  FErrorReader := TExtDataDataReader.CreateInternal(Self, 'errorReader');
  FParamOrder := TExtObjectList.Create(Self, 'paramOrder');
  FReader := TExtDataDataReader.CreateInternal(Self, 'reader');
  FWaitTitle := 'Please Wait...';
  FItems := TExtObjectList.Create(Self, 'items');
end;

{$IFDEF FPC}constructor TExtFormBasicForm.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormBasicForm.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormBasicForm.Add(Fields : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON(Fields) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.ApplyIfToFields(Values : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyIfToFields(' + VarToJSON([Values, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.ApplyToFields(Values : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyToFields(' + VarToJSON([Values, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.CleanDestroyed : TExtFunction; begin
  JSCode(JSName + '.cleanDestroyed();', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.ClearInvalid : TExtFunction; begin
  JSCode(JSName + '.clearInvalid();', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.DoAction(ActionName : String; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.doAction(' + VarToJSON([ActionName, Options, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.DoAction(ActionName : TExtObject; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.doAction(' + VarToJSON([ActionName, false, Options, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.FindField(Id : String) : TExtFunction; begin
  JSCode(JSName + '.findField(' + VarToJSON([Id]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.GetEl : TExtFunction; begin
  JSCode(JSName + '.getEl();', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.GetFieldValues(DirtyOnly : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getFieldValues(' + VarToJSON([DirtyOnly]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.GetValues(AsString : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getValues(' + VarToJSON([AsString]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.LoadRecord(RecordJS : TExtDataRecord) : TExtFunction; begin
  JSCode(JSName + '.loadRecord(' + VarToJSON([RecordJS, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.MarkInvalid(Errors : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.markInvalid(' + VarToJSON(Errors) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.MarkInvalid(Errors : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.markInvalid(' + VarToJSON([Errors, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.Remove(Field : TExtFormField) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([Field, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.Render : TExtFunction; begin
  JSCode(JSName + '.render();', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.SetValues(Values : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.setValues(' + VarToJSON(Values) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.SetValues(Values : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValues(' + VarToJSON([Values, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.Submit(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.submit(' + VarToJSON([Options, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

function TExtFormBasicForm.UpdateRecord(RecordJS : TExtDataRecord) : TExtFunction; begin
  JSCode(JSName + '.updateRecord(' + VarToJSON([RecordJS, false]) + ');', 'TExtFormBasicForm');
  Result := Self;
end;

destructor TExtFormBasicForm.Destroy; begin
  try
    FApi.Free;
    FBaseParams.Free;
    FErrorReader.Free;
    FParamOrder.Free;
    FReader.Free;
    FItems.Free;
  except end;
  inherited;
end;

procedure TExtFormBasicForm.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'actioncomplete') and Assigned(FOnActioncomplete) then
    FOnActioncomplete(TExtFormBasicForm(ParamAsObject('This')), TExtAction(ParamAsObject('Action')))
  else if (AEvtName = 'actionfailed') and Assigned(FOnActionfailed) then
    FOnActionfailed(TExtFormBasicForm(ParamAsObject('This')), TExtAction(ParamAsObject('Action')))
  else if (AEvtName = 'beforeaction') and Assigned(FOnBeforeaction) then
    FOnBeforeaction(TExtFormBasicForm(ParamAsObject('This')), TExtAction(ParamAsObject('Action')));
end;

procedure TExtUxGridRecordForm.SetFCancelIconCls(Value : String); begin
  FCancelIconCls := Value;
  JSCode('cancelIconCls:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFCancelText(Value : String); begin
  FCancelText := Value;
  JSCode('cancelText:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFColumnCount(Value : Integer); begin
  FColumnCount := Value;
  JSCode('columnCount:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFDirtyRowCls(Value : String); begin
  FDirtyRowCls := Value;
  JSCode('dirtyRowCls:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFIconCls(Value : String); begin
  FIconCls := Value;
  JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFOkIconCls(Value : String); begin
  FOkIconCls := Value;
  JSCode('okIconCls:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFOkText(Value : String); begin
  FOkText := Value;
  JSCode('okText:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFNewRowCls(Value : String); begin
  FNewRowCls := Value;
  JSCode('newRowCls:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFShowButtons(Value : Boolean); begin
  FShowButtons := Value;
  JSCode('showButtons:' + VarToJSON([Value]));
end;

procedure TExtUxGridRecordForm.SetFIgnoreFields(Value : TExtObject); begin
  FIgnoreFields := Value;
  Value.DeleteFromGarbage;
  JSCode('ignoreFields:' + VarToJSON([Value, false]));
end;

procedure TExtUxGridRecordForm.SetFReadonlyFields(Value : TExtObject); begin
  FReadonlyFields := Value;
  Value.DeleteFromGarbage;
  JSCode('readonlyFields:' + VarToJSON([Value, false]));
end;

procedure TExtUxGridRecordForm.SetFDisabledFields(Value : TExtObject); begin
  FDisabledFields := Value;
  Value.DeleteFromGarbage;
  JSCode('disabledFields:' + VarToJSON([Value, false]));
end;

procedure TExtUxGridRecordForm.SetFFormConfig(Value : TExtObject); begin
  FFormConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('formConfig:' + VarToJSON([Value, false]));
end;

function TExtUxGridRecordForm.JSClassName : string; begin
  Result := 'Ext.ux.grid.RecordForm';
end;

{$IFDEF FPC}constructor TExtUxGridRecordForm.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUxGridRecordForm.Show(DataRecord : TExtDataRecord; AnimEl : TExtElement = nil) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([DataRecord, false, AnimEl, false]) + ');', 'TExtUxGridRecordForm');
  Result := Self;
end;

procedure TExtFormActionSubmit.SetFClientValidation(Value : Boolean); begin
  FClientValidation := Value;
  JSCode('clientValidation:' + VarToJSON([Value]));
end;

procedure TExtFormActionSubmit.SetFErrorReader(Value : TExtDataDataReader); begin
  FErrorReader := Value;
  Value.DeleteFromGarbage;
  JSCode('errorReader:' + VarToJSON([Value, false]));
end;

function TExtFormActionSubmit.JSClassName : string; begin
  Result := '';
end;

{$IFDEF FPC}constructor TExtFormActionSubmit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormActionLoad.JSClassName : string; begin
  Result := '';
end;

{$IFDEF FPC}constructor TExtFormActionLoad.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormActionDirectLoad.JSClassName : string; begin
  Result := '';
end;

{$IFDEF FPC}constructor TExtFormActionDirectLoad.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormActionDirectSubmit.JSClassName : string; begin
  Result := '';
end;

{$IFDEF FPC}constructor TExtFormActionDirectSubmit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormField.SetFAutoCreate(Value : String); begin
  FAutoCreate := Value;
  JSCode('autoCreate:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFAutoCreateObject(Value : TExtObject); begin
  FAutoCreateObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoCreate:' + VarToJSON([Value, false]));
end;

procedure TExtFormField.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFFieldClass(Value : String); begin
  FFieldClass := Value;
  JSCode('fieldClass:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFFocusClass(Value : String); begin
  FFocusClass := Value;
  JSCode('focusClass:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFInputType(Value : TExtFormFieldInputType); begin
  FInputType := Value;
  JSCode('inputType:"' + EnumToJSString(TypeInfo(TExtFormFieldInputType), ord(Value)) + '"');
end;

procedure TExtFormField.SetFInvalidClass(Value : String); begin
  FInvalidClass := Value;
  JSCode('invalidClass:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFMsgFx(Value : String); begin
  FMsgFx := Value;
  JSCode('msgFx:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFMsgTarget(Value : String); begin
  FMsgTarget := Value;
  JSCode('msgTarget:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFPreventMark(Value : Boolean); begin
  FPreventMark := Value;
  JSCode('preventMark:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  if not ConfigAvailable(JSName) then
    SetReadOnly(Value)
  else
    JSCode('readOnly:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFSubmitValue(Value : Boolean); begin
  FSubmitValue := Value;
  JSCode('submitValue:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFTabIndex(Value : Integer); begin
  FTabIndex := Value;
  JSCode('tabIndex:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFValidateOnBlur(Value : Boolean); begin
  FValidateOnBlur := Value;
  JSCode('validateOnBlur:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFValidationDelay(Value : Integer); begin
  FValidationDelay := Value;
  JSCode('validationDelay:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFValidationEvent(Value : String); begin
  FValidationEvent := Value;
  JSCode('validationEvent:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFValidationEventBoolean(Value : Boolean); begin
  FValidationEventBoolean := Value;
  JSCode('validationEvent:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFValue(Value : String); begin
  FValue := Value;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFLabelJS(Value : TExtElement); begin
  FLabelJS := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.labelJS=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormField.SetFOriginalValue(Value : String); begin
  FOriginalValue := Value;
  JSCode(JSName + '.originalValue=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormField.SetFStartValue(Value : String); begin
  FStartValue := Value;
  JSCode(JSName + '.startValue=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormField.SetFOnBlur(Value : TExtFormFieldOnBlur); begin
  if Assigned(FOnBlur) then
    JSCode(JSName+'.events ["blur"].listeners=[];');
  if Assigned(Value) then
    On('blur', Ajax('blur', ['This', '%0.nm'], true));
  FOnBlur := Value;
end;

procedure TExtFormField.SetFOnChange(Value : TExtFormFieldOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    On('change', Ajax('change', ['This', '%0.nm','NewValue', '%1','OldValue', '%2'], true));
  FOnChange := Value;
end;

procedure TExtFormField.SetFOnFocus(Value : TExtFormFieldOnFocus); begin
  if Assigned(FOnFocus) then
    JSCode(JSName+'.events ["focus"].listeners=[];');
  if Assigned(Value) then
    On('focus', Ajax('focus', ['This', '%0.nm'], true));
  FOnFocus := Value;
end;

procedure TExtFormField.SetFOnInvalid(Value : TExtFormFieldOnInvalid); begin
  if Assigned(FOnInvalid) then
    JSCode(JSName+'.events ["invalid"].listeners=[];');
  if Assigned(Value) then
    On('invalid', Ajax('invalid', ['This', '%0.nm','Msg', '%1'], true));
  FOnInvalid := Value;
end;

procedure TExtFormField.SetFOnSpecialkey(Value : TExtFormFieldOnSpecialkey); begin
  if Assigned(FOnSpecialkey) then
    JSCode(JSName+'.events ["specialkey"].listeners=[];');
  if Assigned(Value) then
    On('specialkey', Ajax('specialkey', ['This', '%0.nm','E', '%1.nm'], true));
  FOnSpecialkey := Value;
end;

procedure TExtFormField.SetFOnValid(Value : TExtFormFieldOnValid); begin
  if Assigned(FOnValid) then
    JSCode(JSName+'.events ["valid"].listeners=[];');
  if Assigned(Value) then
    On('valid', Ajax('valid', ['This', '%0.nm'], true));
  FOnValid := Value;
end;

function TExtFormField.JSClassName : string; begin
  Result := 'Ext.form.Field';
end;

procedure TExtFormField.InitDefaults; begin
  inherited;
  FAutoCreateObject := TExtObject.CreateInternal(Self, 'autoCreate');
  FFieldClass := 'x-form-field';
  FFocusClass := 'x-form-focus';
  FInvalidClass := 'x-form-invalid';
  FInvalidText := 'The value in this field is invalid';
  FMsgFx := 'normal';
  FValidateOnBlur := true;
  FValidationDelay := 250;
  FValidationEvent := 'keyup';
  FLabelJS := TExtElement.CreateInternal(Self, 'labelJS');
end;

{$IFDEF FPC}constructor TExtFormField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormField.ClearInvalid : TExtFunction; begin
  JSCode(JSName + '.clearInvalid();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetActiveError : TExtFunction; begin
  JSCode(JSName + '.getActiveError();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetErrors : TExtFunction; begin
  JSCode(JSName + '.getErrors();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetName : TExtFunction; begin
  JSCode(JSName + '.getName();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetRawValue : TExtFunction; begin
  JSCode(JSName + '.getRawValue();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsValid(PreventMark : Boolean) : TExtFunction; begin
  JSCode(JSName + '.isValid(' + VarToJSON([PreventMark]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.MarkInvalid(Msg : String = '') : TExtFunction; begin
  JSCode(JSName + '.markInvalid(' + VarToJSON([Msg]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.ProcessValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.processValue(' + VarToJSON([Value]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.SetActiveError(Msg : String; SuppressEvent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setActiveError(' + VarToJSON([Msg, SuppressEvent]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.SetRawValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setRawValue(' + VarToJSON([Value]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.SetReadOnly(ReadOnly : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setReadOnly(' + VarToJSON([ReadOnly]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.SetValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.UnsetActiveError(SuppressEvent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.unsetActiveError(' + VarToJSON([SuppressEvent]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.Validate : TExtFunction; begin
  JSCode(JSName + '.validate();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.ValidateValue(The : String) : TExtFunction; begin
  JSCode(JSName + '.validateValue(' + VarToJSON([The]) + ');', 'TExtFormField');
  Result := Self;
end;

destructor TExtFormField.Destroy; begin
  try
    FAutoCreateObject.Free;
    FLabelJS.Free;
  except end;
  inherited;
end;

procedure TExtFormField.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'blur') and Assigned(FOnBlur) then
    FOnBlur(TExtFormField(ParamAsObject('This')))
  else if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtFormField(ParamAsObject('This')), ParamAsString('NewValue'), ParamAsString('OldValue'))
  else if (AEvtName = 'focus') and Assigned(FOnFocus) then
    FOnFocus(TExtFormField(ParamAsObject('This')))
  else if (AEvtName = 'invalid') and Assigned(FOnInvalid) then
    FOnInvalid(TExtFormField(ParamAsObject('This')), ParamAsString('Msg'))
  else if (AEvtName = 'specialkey') and Assigned(FOnSpecialkey) then
    FOnSpecialkey(TExtFormField(ParamAsObject('This')), ExtEventObject)
  else if (AEvtName = 'valid') and Assigned(FOnValid) then
    FOnValid(TExtFormField(ParamAsObject('This')));
end;

procedure TExtFormLabel.SetFForId(Value : String); begin
  FForId := Value;
  JSCode('forId:' + VarToJSON([Value]));
end;

procedure TExtFormLabel.SetFHtml(Value : String); begin
  FHtml := Value;
  JSCode('html:' + VarToJSON([Value]));
end;

procedure TExtFormLabel.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

function TExtFormLabel.JSClassName : string; begin
  Result := 'Ext.form.Label';
end;

procedure TExtFormLabel.InitDefaults; begin
  inherited;
end;

{$IFDEF FPC}constructor TExtFormLabel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormLabel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormLabel.SetText(Text : String; Encode : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text, Encode]) + ');', 'TExtFormLabel');
  Result := Self;
end;

function TExtFormHidden.JSClassName : string; begin
  Result := 'Ext.form.Hidden';
end;

procedure TExtFormHidden.InitDefaults; begin
  inherited;
end;

{$IFDEF FPC}constructor TExtFormHidden.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormHidden.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtFormHtmlEditor.SetFCreateLinkText(Value : String); begin
  FCreateLinkText := Value;
  JSCode('createLinkText:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFDefaultLinkValue(Value : String); begin
  FDefaultLinkValue := Value;
  JSCode('defaultLinkValue:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFDefaultValue(Value : String); begin
  FDefaultValue := Value;
  JSCode('defaultValue:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFEnableAlignments(Value : Boolean); begin
  FEnableAlignments := Value;
  JSCode('enableAlignments:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFEnableColors(Value : Boolean); begin
  FEnableColors := Value;
  JSCode('enableColors:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFEnableFont(Value : Boolean); begin
  FEnableFont := Value;
  JSCode('enableFont:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFEnableFontSize(Value : Boolean); begin
  FEnableFontSize := Value;
  JSCode('enableFontSize:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFEnableFormat(Value : Boolean); begin
  FEnableFormat := Value;
  JSCode('enableFormat:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFEnableLinks(Value : Boolean); begin
  FEnableLinks := Value;
  JSCode('enableLinks:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFEnableLists(Value : Boolean); begin
  FEnableLists := Value;
  JSCode('enableLists:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFEnableSourceEdit(Value : Boolean); begin
  FEnableSourceEdit := Value;
  JSCode('enableSourceEdit:' + VarToJSON([Value]));
end;

procedure TExtFormHtmlEditor.SetFFontFamilies(Value : TExtObjectList); begin
  FFontFamilies := Value;
  Value.DeleteFromGarbage;
  JSCode('fontFamilies:' + VarToJSON([Value, false]));
end;

procedure TExtFormHtmlEditor.SetFButtonTips(Value : TExtObject); begin
  FButtonTips := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.buttonTips=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormHtmlEditor.SetFOnActivate(Value : TExtFormHtmlEditorOnActivate); begin
  if Assigned(FOnActivate) then
    JSCode(JSName+'.events ["activate"].listeners=[];');
  if Assigned(Value) then
    On('activate', Ajax('activate', ['This', '%0.nm'], true));
  FOnActivate := Value;
end;

procedure TExtFormHtmlEditor.SetFOnBeforepush(Value : TExtFormHtmlEditorOnBeforepush); begin
  if Assigned(FOnBeforepush) then
    JSCode(JSName+'.events ["beforepush"].listeners=[];');
  if Assigned(Value) then
    On('beforepush', Ajax('beforepush', ['This', '%0.nm','Html', '%1'], true));
  FOnBeforepush := Value;
end;

procedure TExtFormHtmlEditor.SetFOnBeforesync(Value : TExtFormHtmlEditorOnBeforesync); begin
  if Assigned(FOnBeforesync) then
    JSCode(JSName+'.events ["beforesync"].listeners=[];');
  if Assigned(Value) then
    On('beforesync', Ajax('beforesync', ['This', '%0.nm','Html', '%1'], true));
  FOnBeforesync := Value;
end;

procedure TExtFormHtmlEditor.SetFOnEditmodechange(Value : TExtFormHtmlEditorOnEditmodechange); begin
  if Assigned(FOnEditmodechange) then
    JSCode(JSName+'.events ["editmodechange"].listeners=[];');
  if Assigned(Value) then
    On('editmodechange', Ajax('editmodechange', ['This', '%0.nm','SourceEdit', '%1'], true));
  FOnEditmodechange := Value;
end;

procedure TExtFormHtmlEditor.SetFOnInitialize(Value : TExtFormHtmlEditorOnInitialize); begin
  if Assigned(FOnInitialize) then
    JSCode(JSName+'.events ["initialize"].listeners=[];');
  if Assigned(Value) then
    On('initialize', Ajax('initialize', ['This', '%0.nm'], true));
  FOnInitialize := Value;
end;

procedure TExtFormHtmlEditor.SetFOnPush(Value : TExtFormHtmlEditorOnPush); begin
  if Assigned(FOnPush) then
    JSCode(JSName+'.events ["push"].listeners=[];');
  if Assigned(Value) then
    On('push', Ajax('push', ['This', '%0.nm','Html', '%1'], true));
  FOnPush := Value;
end;

procedure TExtFormHtmlEditor.SetFOnSync(Value : TExtFormHtmlEditorOnSync); begin
  if Assigned(FOnSync) then
    JSCode(JSName+'.events ["sync"].listeners=[];');
  if Assigned(Value) then
    On('sync', Ajax('sync', ['This', '%0.nm','Html', '%1'], true));
  FOnSync := Value;
end;

function TExtFormHtmlEditor.JSClassName : string; begin
  Result := 'Ext.form.HtmlEditor';
end;

procedure TExtFormHtmlEditor.InitDefaults; begin
  inherited;
  FEnableAlignments := true;
  FEnableColors := true;
  FEnableFont := true;
  FEnableFontSize := true;
  FEnableFormat := true;
  FEnableLinks := true;
  FEnableLists := true;
  FEnableSourceEdit := true;
  FFontFamilies := TExtObjectList.Create(Self, 'fontFamilies');
  FButtonTips := TExtObject.CreateInternal(Self, 'buttonTips');
end;

{$IFDEF FPC}constructor TExtFormHtmlEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormHtmlEditor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormHtmlEditor.CleanHtml(Html : String) : TExtFunction; begin
  JSCode(JSName + '.cleanHtml(' + VarToJSON([Html]) + ');', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.ExecCmd(Cmd : String; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.execCmd(' + VarToJSON([Cmd, Value]) + ');', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.ExecCmd(Cmd : String; Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.execCmd(' + VarToJSON([Cmd, Value]) + ');', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.GetDocMarkup : TExtFunction; begin
  JSCode(JSName + '.getDocMarkup();', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.GetToolbar : TExtFunction; begin
  JSCode(JSName + '.getToolbar();', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.InsertAtCursor(Text : String) : TExtFunction; begin
  JSCode(JSName + '.insertAtCursor(' + VarToJSON([Text]) + ');', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.PushValue : TExtFunction; begin
  JSCode(JSName + '.pushValue();', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.RelayCmd(Cmd : String; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayCmd(' + VarToJSON([Cmd, Value]) + ');', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.RelayCmd(Cmd : String; Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.relayCmd(' + VarToJSON([Cmd, Value]) + ');', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.SyncValue : TExtFunction; begin
  JSCode(JSName + '.syncValue();', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.ToggleSourceEdit(SourceEdit : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toggleSourceEdit(' + VarToJSON([SourceEdit]) + ');', 'TExtFormHtmlEditor');
  Result := Self;
end;

function TExtFormHtmlEditor.UpdateToolbar : TExtFunction; begin
  JSCode(JSName + '.updateToolbar();', 'TExtFormHtmlEditor');
  Result := Self;
end;

destructor TExtFormHtmlEditor.Destroy; begin
  try
    FFontFamilies.Free;
    FButtonTips.Free;
  except end;
  inherited;
end;

procedure TExtFormHtmlEditor.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'activate') and Assigned(FOnActivate) then
    FOnActivate(TExtFormHtmlEditor(ParamAsObject('This')))
  else if (AEvtName = 'beforepush') and Assigned(FOnBeforepush) then
    FOnBeforepush(TExtFormHtmlEditor(ParamAsObject('This')), ParamAsString('Html'))
  else if (AEvtName = 'beforesync') and Assigned(FOnBeforesync) then
    FOnBeforesync(TExtFormHtmlEditor(ParamAsObject('This')), ParamAsString('Html'))
  else if (AEvtName = 'editmodechange') and Assigned(FOnEditmodechange) then
    FOnEditmodechange(TExtFormHtmlEditor(ParamAsObject('This')), ParamAsBoolean('SourceEdit'))
  else if (AEvtName = 'initialize') and Assigned(FOnInitialize) then
    FOnInitialize(TExtFormHtmlEditor(ParamAsObject('This')))
  else if (AEvtName = 'push') and Assigned(FOnPush) then
    FOnPush(TExtFormHtmlEditor(ParamAsObject('This')), ParamAsString('Html'))
  else if (AEvtName = 'sync') and Assigned(FOnSync) then
    FOnSync(TExtFormHtmlEditor(ParamAsObject('This')), ParamAsString('Html'));
end;

procedure TExtUxCodePress.SetFAutoComplete(Value : Boolean); begin
  FAutoComplete := Value;
  JSCode('autoComplete:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFAutoResize(Value : Boolean); begin
  FAutoResize := Value;
  JSCode('autoResize:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFCode(Value : String); begin
  FCode := Value;
  if not ConfigAvailable(JSName) then
    SetCode(Value)
  else
    JSCode('code:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFHeight(Value : Integer); begin
  FHeight := Value;
  JSCode('height:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFLanguage(Value : String); begin
  FLanguage := Value;
  JSCode('language:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFLineNumbers(Value : Boolean); begin
  FLineNumbers := Value;
  JSCode('lineNumbers:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFPath(Value : String); begin
  FPath := Value;
  JSCode('path:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  JSCode('readOnly:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFSourceEl(Value : String); begin
  FSourceEl := Value;
  JSCode('sourceEl:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFTrim(Value : Boolean); begin
  FTrim := Value;
  JSCode('trim:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtUxCodePress.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

function TExtUxCodePress.JSClassName : string; begin
  Result := 'Ext.ux.CodePress';
end;

{$IFDEF FPC}constructor TExtUxCodePress.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUxCodePress.Edit(Obj : TExtObject; Language : String) : TExtFunction; begin
  JSCode(JSName + '.edit(' + VarToJSON([Obj, false, Language]) + ');', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.SetCode(Code : String) : TExtFunction; begin
  JSCode(JSName + '.setCode(' + VarToJSON([Code]) + ');', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.GetCode : TExtFunction; begin
  JSCode(JSName + '.getCode();', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.GetLanguage : TExtFunction; begin
  JSCode(JSName + '.getLanguage();', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.SetValue(Code : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Code]) + ');', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.Resize : TExtFunction; begin
  JSCode(JSName + '.resize();', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.ToggleAutoComplete : TExtFunction; begin
  JSCode(JSName + '.toggleAutoComplete();', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.ToggleReadOnly : TExtFunction; begin
  JSCode(JSName + '.toggleReadOnly();', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.ToggleLineNumbers : TExtFunction; begin
  JSCode(JSName + '.toggleLineNumbers();', 'TExtUxCodePress');
  Result := Self;
end;

function TExtUxCodePress.ToggleEditor : TExtFunction; begin
  JSCode(JSName + '.toggleEditor();', 'TExtUxCodePress');
  Result := Self;
end;

procedure TExtFormTextField.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFDisableKeyFilter(Value : Boolean); begin
  FDisableKeyFilter := Value;
  JSCode('disableKeyFilter:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFEmptyClass(Value : String); begin
  FEmptyClass := Value;
  JSCode('emptyClass:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFEmptyText(Value : String); begin
  FEmptyText := Value;
  JSCode('emptyText:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFEnableKeyEvents(Value : Boolean); begin
  FEnableKeyEvents := Value;
  JSCode('enableKeyEvents:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFGrow(Value : Boolean); begin
  FGrow := Value;
  JSCode('grow:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFGrowMax(Value : Integer); begin
  FGrowMax := Value;
  JSCode('growMax:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFGrowMin(Value : Integer); begin
  FGrowMin := Value;
  JSCode('growMin:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFMaskRe(Value : TRegExp); begin
  FMaskRe := Value;
  JSCode('maskRe:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormTextField.SetFMaxLength(Value : Integer); begin
  FMaxLength := Value;
  JSCode('maxLength:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFMaxLengthText(Value : String); begin
  FMaxLengthText := Value;
  JSCode('maxLengthText:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFMinLength(Value : Integer); begin
  FMinLength := Value;
  JSCode('minLength:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFMinLengthText(Value : String); begin
  FMinLengthText := Value;
  JSCode('minLengthText:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFRegex(Value : TRegExp); begin
  FRegex := Value;
  JSCode('regex:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormTextField.SetFRegexText(Value : String); begin
  FRegexText := Value;
  JSCode('regexText:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFSelectOnFocus(Value : Boolean); begin
  FSelectOnFocus := Value;
  JSCode('selectOnFocus:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFStripCharsRe(Value : TRegExp); begin
  FStripCharsRe := Value;
  JSCode('stripCharsRe:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormTextField.SetFValidator(Value : TExtFunction); begin
  FValidator := Value;
  JSCode('validator:' + VarToJSON([Value, true]));
end;

procedure TExtFormTextField.SetFVtype(Value : String); begin
  FVtype := Value;
  JSCode('vtype:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFVtypeText(Value : String); begin
  FVtypeText := Value;
  JSCode('vtypeText:' + VarToJSON([Value]));
end;

procedure TExtFormTextField.SetFOnAutosize(Value : TExtFormTextFieldOnAutosize); begin
  if Assigned(FOnAutosize) then
    JSCode(JSName+'.events ["autosize"].listeners=[];');
  if Assigned(Value) then
    On('autosize', Ajax('autosize', ['This', '%0.nm','Width', '%1'], true));
  FOnAutosize := Value;
end;

procedure TExtFormTextField.SetFOnKeydown(Value : TExtFormTextFieldOnKeydown); begin
  if Assigned(FOnKeydown) then
    JSCode(JSName+'.events ["keydown"].listeners=[];');
  if Assigned(Value) then
    On('keydown', Ajax('keydown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeydown := Value;
end;

procedure TExtFormTextField.SetFOnKeypress(Value : TExtFormTextFieldOnKeypress); begin
  if Assigned(FOnKeypress) then
    JSCode(JSName+'.events ["keypress"].listeners=[];');
  if Assigned(Value) then
    On('keypress', Ajax('keypress', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeypress := Value;
end;

procedure TExtFormTextField.SetFOnKeyup(Value : TExtFormTextFieldOnKeyup); begin
  if Assigned(FOnKeyup) then
    JSCode(JSName+'.events ["keyup"].listeners=[];');
  if Assigned(Value) then
    On('keyup', Ajax('keyup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeyup := Value;
end;

function TExtFormTextField.JSClassName : string; begin
  Result := 'Ext.form.TextField';
end;

procedure TExtFormTextField.InitDefaults; begin
  inherited;
  FAllowBlank := true;
  FBlankText := 'This field is required';
  FEmptyClass := 'x-form-empty-field';
  FGrowMax := 800;
  FGrowMin := 30;
  FMaxLengthText := 'The maximum length for this field is {maxLength}';
  FMinLength := 0;
  FMinLengthText := 'The minimum length for this field is {minLength}';
end;

{$IFDEF FPC}constructor TExtFormTextField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormTextField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormTextField.AutoSize : TExtFunction; begin
  JSCode(JSName + '.autoSize();', 'TExtFormTextField');
  Result := Self;
end;

function TExtFormTextField.GetErrors(Value : String) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value]) + ');', 'TExtFormTextField');
  Result := Self;
end;

function TExtFormTextField.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormTextField');
  Result := Self;
end;

function TExtFormTextField.SelectText(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.selectText(' + VarToJSON([Start, EndJS]) + ');', 'TExtFormTextField');
  Result := Self;
end;

procedure TExtFormTextField.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'autosize') and Assigned(FOnAutosize) then
    FOnAutosize(TExtFormTextField(ParamAsObject('This')), ParamAsInteger('Width'))
  else if (AEvtName = 'keydown') and Assigned(FOnKeydown) then
    FOnKeydown(TExtFormTextField(ParamAsObject('This')), ExtEventObject)
  else if (AEvtName = 'keypress') and Assigned(FOnKeypress) then
    FOnKeypress(TExtFormTextField(ParamAsObject('This')), ExtEventObject)
  else if (AEvtName = 'keyup') and Assigned(FOnKeyup) then
    FOnKeyup(TExtFormTextField(ParamAsObject('This')), ExtEventObject);
end;

procedure TExtFormSliderField.SetFTipText(Value : TExtFunction); begin
  FTipText := Value;
  JSCode('tipText:' + VarToJSON([Value, true]));
end;

procedure TExtFormSliderField.SetFUseTips(Value : Boolean); begin
  FUseTips := Value;
  JSCode('useTips:' + VarToJSON([Value]));
end;

function TExtFormSliderField.JSClassName : string; begin
  Result := 'Ext.form.SliderField';
end;

procedure TExtFormSliderField.InitDefaults; begin
  inherited;
end;

{$IFDEF FPC}constructor TExtFormSliderField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormSliderField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormSliderField.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormSliderField');
  Result := Self;
end;

function TExtFormSliderField.SetMaxValue(V : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([V]) + ');', 'TExtFormSliderField');
  Result := Self;
end;

function TExtFormSliderField.SetMinValue(V : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([V]) + ');', 'TExtFormSliderField');
  Result := Self;
end;

function TExtFormSliderField.SetValue(V : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([V, Animate]) + ');', 'TExtFormSliderField');
  Result := Self;
end;

procedure TExtFormDisplayField.SetFFieldClass(Value : String); begin
  FFieldClass := Value;
  JSCode('fieldClass:' + VarToJSON([Value]));
end;

procedure TExtFormDisplayField.SetFHtmlEncode(Value : Boolean); begin
  FHtmlEncode := Value;
  JSCode('htmlEncode:' + VarToJSON([Value]));
end;

function TExtFormDisplayField.JSClassName : string; begin
  Result := 'Ext.form.DisplayField';
end;

procedure TExtFormDisplayField.InitDefaults; begin
  inherited;
  FFieldClass := 'x-form-display-field';
end;

{$IFDEF FPC}constructor TExtFormDisplayField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormDisplayField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtFormCompositeField.SetFY(Value : Integer); begin
  FY := Value;
  JSCode('y:' + VarToJSON([Value]));
end;

procedure TExtFormCompositeField.SetFDefaultMargins(Value : String); begin
  FDefaultMargins := Value;
  JSCode('defaultMargins:' + VarToJSON([Value]));
end;

procedure TExtFormCompositeField.SetFFieldErrors(Value : TExtObjectList); begin
  FFieldErrors := Value;
  Value.DeleteFromGarbage;
  JSCode('fieldErrors:' + VarToJSON([Value, false]));
end;

procedure TExtFormCompositeField.SetFInnerCt(Value : TExtContainer); begin
  FInnerCt := Value;
  Value.DeleteFromGarbage;
  JSCode('innerCt:' + VarToJSON([Value, false]));
end;

procedure TExtFormCompositeField.SetFIsComposite(Value : Boolean); begin
  FIsComposite := Value;
  JSCode('isComposite:' + VarToJSON([Value]));
end;

procedure TExtFormCompositeField.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormCompositeField.SetFRendered(Value : Boolean); begin
  FRendered := Value;
  JSCode('rendered:' + VarToJSON([Value]));
end;

function TExtFormCompositeField.JSClassName : string; begin
  Result := 'Ext.form.CompositeField';
end;

procedure TExtFormCompositeField.InitDefaults; begin
  inherited;
  FFieldErrors := TExtObjectList.Create(Self, 'fieldErrors');
  FInnerCt := TExtContainer.CreateInternal(Self, 'innerCt');
  FItems := TExtObjectList.Create(Self, 'items');
  FRendered := true;
end;

{$IFDEF FPC}constructor TExtFormCompositeField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormCompositeField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormCompositeField.BuildCombinedErrorMessage(Errors : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.buildCombinedErrorMessage(' + VarToJSON(Errors) + ');', 'TExtFormCompositeField');
  Result := Self;
end;

function TExtFormCompositeField.BuildLabel(Segments : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.buildLabel(' + VarToJSON(Segments) + ');', 'TExtFormCompositeField');
  Result := Self;
end;

function TExtFormCompositeField.ClearInvalidChildren : TExtFunction; begin
  JSCode(JSName + '.clearInvalidChildren();', 'TExtFormCompositeField');
  Result := Self;
end;

function TExtFormCompositeField.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormCompositeField');
  Result := Self;
end;

function TExtFormCompositeField.OnFieldClearInvalid(Field : TExtFormField) : TExtFunction; begin
  JSCode(JSName + '.onFieldClearInvalid(' + VarToJSON([Field, false]) + ');', 'TExtFormCompositeField');
  Result := Self;
end;

function TExtFormCompositeField.OnFieldMarkInvalid(Field : TExtFormField; Message : String) : TExtFunction; begin
  JSCode(JSName + '.onFieldMarkInvalid(' + VarToJSON([Field, false, Message]) + ');', 'TExtFormCompositeField');
  Result := Self;
end;

function TExtFormCompositeField.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormCompositeField');
  Result := Self;
end;

function TExtFormCompositeField.SortErrors : TExtFunction; begin
  JSCode(JSName + '.sortErrors();', 'TExtFormCompositeField');
  Result := Self;
end;

function TExtFormCompositeField.ValidateValue : TExtFunction; begin
  JSCode(JSName + '.validateValue();', 'TExtFormCompositeField');
  Result := Self;
end;

destructor TExtFormCompositeField.Destroy; begin
  try
    FFieldErrors.Free;
    FInnerCt.Free;
    FItems.Free;
  except end;
  inherited;
end;

procedure TExtFormCheckbox.SetFAutoCreate(Value : String); begin
  FAutoCreate := Value;
  JSCode('autoCreate:' + VarToJSON([Value]));
end;

procedure TExtFormCheckbox.SetFAutoCreateObject(Value : TExtObject); begin
  FAutoCreateObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoCreate:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckbox.SetFBoxLabel(Value : String); begin
  FBoxLabel := Value;
  JSCode('boxLabel:' + VarToJSON([Value]));
end;

procedure TExtFormCheckbox.SetFBoxLabel_(Value : String); begin
  FBoxLabel_ := Value;
  JSCode('boxLabel:' + VarToJSON([Value]));
end;

procedure TExtFormCheckbox.SetFChecked(Value : Boolean); begin
  FChecked := Value;
  JSCode('checked:' + VarToJSON([Value]));
end;

procedure TExtFormCheckbox.SetFFieldClass(Value : String); begin
  FFieldClass := Value;
  JSCode('fieldClass:' + VarToJSON([Value]));
end;

procedure TExtFormCheckbox.SetFFocusClass(Value : String); begin
  FFocusClass := Value;
  JSCode('focusClass:' + VarToJSON([Value]));
end;

procedure TExtFormCheckbox.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtFormCheckbox.SetFInputValue(Value : String); begin
  FInputValue := Value;
  JSCode('inputValue:' + VarToJSON([Value]));
end;

procedure TExtFormCheckbox.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckbox.SetFOnCheck(Value : TExtFormCheckboxOnCheck); begin
  if Assigned(FOnCheck) then
    JSCode(JSName+'.events ["check"].listeners=[];');
  if Assigned(Value) then
    On('check', Ajax('check', ['This', '%0.nm','Checked', '%1'], true));
  FOnCheck := Value;
end;

function TExtFormCheckbox.JSClassName : string; begin
  Result := 'Ext.form.Checkbox';
end;

procedure TExtFormCheckbox.InitDefaults; begin
  inherited;
  FAutoCreate := 'input';
  FAutoCreateObject := TExtObject.CreateInternal(Self, 'autoCreate');
  FFieldClass := 'x-form-field';
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtFormCheckbox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormCheckbox.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormCheckbox.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormCheckbox');
  Result := Self;
end;

function TExtFormCheckbox.SetValue(Checked : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Checked]) + ');', 'TExtFormCheckbox');
  Result := Self;
end;

function TExtFormCheckbox.SetValue(Checked : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Checked]) + ');', 'TExtFormCheckbox');
  Result := Self;
end;

destructor TExtFormCheckbox.Destroy; begin
  try
    FAutoCreateObject.Free;
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtFormCheckbox.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'check') and Assigned(FOnCheck) then
    FOnCheck(TExtFormCheckbox(ParamAsObject('This')), ParamAsBoolean('Checked'));
end;

procedure TExtFormCheckboxGroup.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFColumns(Value : String); begin
  FColumns := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFColumnsNumber(Value : Integer); begin
  FColumnsNumber := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFColumnsArray(Value : TExtObjectList); begin
  FColumnsArray := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckboxGroup.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckboxGroup.SetFVertical(Value : Boolean); begin
  FVertical := Value;
  JSCode('vertical:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFOnChange(Value : TExtFormCheckboxGroupOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    On('change', Ajax('change', ['This', '%0.nm','Checked', '%1.nm'], true));
  FOnChange := Value;
end;

function TExtFormCheckboxGroup.JSClassName : string; begin
  Result := 'Ext.form.CheckboxGroup';
end;

procedure TExtFormCheckboxGroup.InitDefaults; begin
  inherited;
  FAllowBlank := true;
  FBlankText := 'You must select at least one item in this group';
  FColumnsArray := TExtObjectList.Create(Self, 'columns');
  FItems := TExtObjectList.Create(Self, 'items');
end;

{$IFDEF FPC}constructor TExtFormCheckboxGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormCheckboxGroup.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormCheckboxGroup.GetErrors : TExtFunction; begin
  JSCode(JSName + '.getErrors();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.SetValue(Id : String; Value : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Id, Value]) + ');', 'TExtFormCheckboxGroup');
  Result := Self;
end;

destructor TExtFormCheckboxGroup.Destroy; begin
  try
    FColumnsArray.Free;
    FItems.Free;
  except end;
  inherited;
end;

procedure TExtFormCheckboxGroup.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtFormCheckboxGroup(ParamAsObject('This')), TExtObjectList(ParamAsObject('Checked')));
end;

procedure TExtFormTextArea.SetFAutoCreate(Value : String); begin
  FAutoCreate := Value;
  JSCode('autoCreate:' + VarToJSON([Value]));
end;

procedure TExtFormTextArea.SetFAutoCreateObject(Value : TExtObject); begin
  FAutoCreateObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoCreate:' + VarToJSON([Value, false]));
end;

procedure TExtFormTextArea.SetFGrowMax(Value : Integer); begin
  FGrowMax := Value;
  JSCode('growMax:' + VarToJSON([Value]));
end;

procedure TExtFormTextArea.SetFGrowMin(Value : Integer); begin
  FGrowMin := Value;
  JSCode('growMin:' + VarToJSON([Value]));
end;

procedure TExtFormTextArea.SetFPreventScrollbars(Value : Boolean); begin
  FPreventScrollbars := Value;
  JSCode('preventScrollbars:' + VarToJSON([Value]));
end;

function TExtFormTextArea.JSClassName : string; begin
  Result := 'Ext.form.TextArea';
end;

procedure TExtFormTextArea.InitDefaults; begin
  inherited;
  FAutoCreateObject := TExtObject.CreateInternal(Self, 'autoCreate');
  FGrowMax := 1000;
  FGrowMin := 60;
end;

{$IFDEF FPC}constructor TExtFormTextArea.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormTextArea.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormTextArea.AutoSize : TExtFunction; begin
  JSCode(JSName + '.autoSize();', 'TExtFormTextArea');
  Result := Self;
end;

destructor TExtFormTextArea.Destroy; begin
  try
    FAutoCreateObject.Free;
  except end;
  inherited;
end;

procedure TExtFormTriggerField.SetFAutoCreate(Value : String); begin
  FAutoCreate := Value;
  JSCode('autoCreate:' + VarToJSON([Value]));
end;

procedure TExtFormTriggerField.SetFAutoCreateObject(Value : TExtObject); begin
  FAutoCreateObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoCreate:' + VarToJSON([Value, false]));
end;

procedure TExtFormTriggerField.SetFEditable(Value : Boolean); begin
  FEditable := Value;
  if not ConfigAvailable(JSName) then
    SetEditable(Value)
  else
    JSCode('editable:' + VarToJSON([Value]));
end;

procedure TExtFormTriggerField.SetFHideTrigger(Value : Boolean); begin
  FHideTrigger := Value;
  JSCode('hideTrigger:' + VarToJSON([Value]));
end;

procedure TExtFormTriggerField.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  if not ConfigAvailable(JSName) then
    SetReadOnly(Value)
  else
    JSCode('readOnly:' + VarToJSON([Value]));
end;

procedure TExtFormTriggerField.SetFTriggerClass(Value : String); begin
  FTriggerClass := Value;
  JSCode('triggerClass:' + VarToJSON([Value]));
end;

procedure TExtFormTriggerField.SetFTriggerConfig(Value : String); begin
  FTriggerConfig := Value;
  JSCode('triggerConfig:' + VarToJSON([Value]));
end;

procedure TExtFormTriggerField.SetFWrapFocusClass(Value : String); begin
  FWrapFocusClass := Value;
  JSCode('wrapFocusClass:' + VarToJSON([Value]));
end;

function TExtFormTriggerField.JSClassName : string; begin
  Result := 'Ext.form.TriggerField';
end;

procedure TExtFormTriggerField.InitDefaults; begin
  inherited;
  FAutoCreateObject := TExtObject.CreateInternal(Self, 'autoCreate');
  FEditable := true;
end;

{$IFDEF FPC}constructor TExtFormTriggerField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormTriggerField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormTriggerField.OnTriggerClick(E : TEventObject) : TExtFunction; begin
  JSCode(JSName + '.onTriggerClick(' + VarToJSON([E, false]) + ');', 'TExtFormTriggerField');
  Result := Self;
end;

function TExtFormTriggerField.SetEditable(Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setEditable(' + VarToJSON([Value]) + ');', 'TExtFormTriggerField');
  Result := Self;
end;

function TExtFormTriggerField.SetReadOnly(Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setReadOnly(' + VarToJSON([Value]) + ');', 'TExtFormTriggerField');
  Result := Self;
end;

destructor TExtFormTriggerField.Destroy; begin
  try
    FAutoCreateObject.Free;
  except end;
  inherited;
end;

procedure TExtFormNumberField.SetFAllowDecimals(Value : Boolean); begin
  FAllowDecimals := Value;
  JSCode('allowDecimals:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFAllowNegative(Value : Boolean); begin
  FAllowNegative := Value;
  JSCode('allowNegative:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFBaseChars(Value : String); begin
  FBaseChars := Value;
  JSCode('baseChars:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFDecimalPrecision(Value : Integer); begin
  FDecimalPrecision := Value;
  JSCode('decimalPrecision:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFDecimalSeparator(Value : String); begin
  FDecimalSeparator := Value;
  JSCode('decimalSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFFieldClass(Value : String); begin
  FFieldClass := Value;
  JSCode('fieldClass:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFMaxValue(Value : Integer); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFMinValue(Value : Integer); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormNumberField.SetFNanText(Value : String); begin
  FNanText := Value;
  JSCode('nanText:' + VarToJSON([Value]));
end;

function TExtFormNumberField.JSClassName : string; begin
  Result := 'Ext.form.NumberField';
end;

procedure TExtFormNumberField.InitDefaults; begin
  inherited;
  FAllowDecimals := true;
  FAllowNegative := true;
  FBaseChars := '0123456789';
  FDecimalPrecision := 2;
  FDecimalSeparator := '.';
  FFieldClass := 'x-form-field x-form-num-field';
  FMaxText := 'The maximum value for this field is {maxValue}';
  FMinText := 'The minimum value for this field is {minValue}';
  FNanText := '{value} is not a valid number';
end;

{$IFDEF FPC}constructor TExtFormNumberField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormNumberField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormNumberField.GetErrors(Value : String) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value]) + ');', 'TExtFormNumberField');
  Result := Self;
end;

function TExtFormNumberField.SetMaxValue(Value : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormNumberField');
  Result := Self;
end;

function TExtFormNumberField.SetMinValue(Value : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormNumberField');
  Result := Self;
end;

procedure TExtFormFieldSet.SetFAnimCollapse(Value : Boolean); begin
  FAnimCollapse := Value;
  JSCode('animCollapse:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCheckboxName(Value : String); begin
  FCheckboxName := Value;
  JSCode('checkboxName:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCheckboxToggle(Value : String); begin
  FCheckboxToggle := Value;
  JSCode('checkboxToggle:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFItemCls(Value : String); begin
  FItemCls := Value;
  JSCode('itemCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFLabelWidth(Value : Integer); begin
  FLabelWidth := Value;
  JSCode('labelWidth:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFLayout(Value : String); begin
  FLayout := Value;
  JSCode('layout:' + VarToJSON([Value]));
end;

function TExtFormFieldSet.JSClassName : string; begin
  Result := 'Ext.form.FieldSet';
end;

procedure TExtFormFieldSet.InitDefaults; begin
  inherited;
  FBaseCls := 'x-fieldset';
  FCheckboxName := '[checkbox id]-checkbox';
  FLayout := 'form';
end;

{$IFDEF FPC}constructor TExtFormFieldSet.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldSet.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldSet.OnCheckClick : TExtFunction; begin
  JSCode(JSName + '.onCheckClick();', 'TExtFormFieldSet');
  Result := Self;
end;

procedure TExtFormFormPanel.SetFButtons(Value : TExtObjectList); begin
  FButtons := Value;
  Value.DeleteFromGarbage;
  JSCode('buttons:' + VarToJSON([Value, false]));
end;

procedure TExtFormFormPanel.SetFFormId(Value : String); begin
  FFormId := Value;
  JSCode('formId:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFHideLabels(Value : Boolean); begin
  FHideLabels := Value;
  JSCode('hideLabels:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFItemCls(Value : String); begin
  FItemCls := Value;
  JSCode('itemCls:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFLabelAlign(Value : TExtFormFormPanelLabelAlign); begin
  FLabelAlign := Value;
  JSCode('labelAlign:"' + EnumToJSString(TypeInfo(TExtFormFormPanelLabelAlign), ord(Value)) + '"');
end;

procedure TExtFormFormPanel.SetFLabelPad(Value : Integer); begin
  FLabelPad := Value;
  JSCode('labelPad:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFLabelSeparator(Value : String); begin
  FLabelSeparator := Value;
  JSCode('labelSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFLabelWidth(Value : Integer); begin
  FLabelWidth := Value;
  JSCode('labelWidth:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFLayout(Value : String); begin
  FLayout := Value;
  JSCode('layout:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFMinButtonWidth(Value : Integer); begin
  FMinButtonWidth := Value;
  JSCode('minButtonWidth:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFMonitorPoll(Value : Integer); begin
  FMonitorPoll := Value;
  JSCode('monitorPoll:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFMonitorValid(Value : Boolean); begin
  FMonitorValid := Value;
  JSCode('monitorValid:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFFileUpload(Value : Boolean); begin
  FFileUpload := Value;
  JSCode('fileUpload:' + VarToJSON([Value]));
end;

procedure TExtFormFormPanel.SetFOnClientvalidation(Value : TExtFormFormPanelOnClientvalidation); begin
  if Assigned(FOnClientvalidation) then
    JSCode(JSName+'.events ["clientvalidation"].listeners=[];');
  if Assigned(Value) then
    On('clientvalidation', Ajax('clientvalidation', ['This', '%0.nm','Valid', '%1'], true));
  FOnClientvalidation := Value;
end;

function TExtFormFormPanel.JSClassName : string; begin
  Result := 'Ext.form.FormPanel';
end;

procedure TExtFormFormPanel.InitDefaults; begin
  inherited;
  FButtons := TExtObjectList.Create(Self, 'buttons');
  FLabelPad := 5;
  FLabelWidth := 100;
  FMinButtonWidth := 75;
  FMonitorPoll := 200;
  FForm := TExtFormBasicForm.CreateInternal(Self, '');
end;

{$IFDEF FPC}constructor TExtFormFormPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFormPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFormPanel.GetForm : TExtFunction; begin
  JSCode(JSName + '.getForm();', 'TExtFormFormPanel');
  Result := Self;
end;

function TExtFormFormPanel.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtFormFormPanel');
  Result := Self;
end;

function TExtFormFormPanel.StartMonitoring : TExtFunction; begin
  JSCode(JSName + '.startMonitoring();', 'TExtFormFormPanel');
  Result := Self;
end;

function TExtFormFormPanel.StopMonitoring : TExtFunction; begin
  JSCode(JSName + '.stopMonitoring();', 'TExtFormFormPanel');
  Result := Self;
end;

destructor TExtFormFormPanel.Destroy; begin
  try
    FButtons.Free;
    FForm.Free;
  except end;
  inherited;
end;

procedure TExtFormFormPanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'clientvalidation') and Assigned(FOnClientvalidation) then
    FOnClientvalidation(TExtFormFormPanel(ParamAsObject('This')), ParamAsBoolean('Valid'));
end;

procedure TExtFormRadioGroup.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormRadioGroup.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

procedure TExtFormRadioGroup.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormRadioGroup.SetFOnChange(Value : TExtFormRadioGroupOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    On('change', Ajax('change', ['This', '%0.nm','Checked', '%1.nm'], true));
  FOnChange := Value;
end;

function TExtFormRadioGroup.JSClassName : string; begin
  Result := 'Ext.form.RadioGroup';
end;

procedure TExtFormRadioGroup.InitDefaults; begin
  inherited;
  FAllowBlank := true;
  FBlankText := 'You must select one item in this group';
  FItems := TExtObjectList.Create(Self, 'items');
end;

{$IFDEF FPC}constructor TExtFormRadioGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormRadioGroup.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormRadioGroup.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormRadioGroup');
  Result := Self;
end;

function TExtFormRadioGroup.OnSetValue(Id : String; Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.onSetValue(' + VarToJSON([Id, Value]) + ');', 'TExtFormRadioGroup');
  Result := Self;
end;

function TExtFormRadioGroup.OnSetValue(Id : TExtFormRadio; Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.onSetValue(' + VarToJSON([Id, false, Value]) + ');', 'TExtFormRadioGroup');
  Result := Self;
end;

destructor TExtFormRadioGroup.Destroy; begin
  try
    FItems.Free;
  except end;
  inherited;
end;

procedure TExtFormRadioGroup.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtFormRadioGroup(ParamAsObject('This')), TExtFormRadio(ParamAsObject('Checked')));
end;

function TExtFormRadio.JSClassName : string; begin
  Result := 'Ext.form.Radio';
end;

procedure TExtFormRadio.InitDefaults; begin
  inherited;
end;

{$IFDEF FPC}constructor TExtFormRadio.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormRadio.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormRadio.GetGroupValue : TExtFunction; begin
  JSCode(JSName + '.getGroupValue();', 'TExtFormRadio');
  Result := Self;
end;

function TExtFormRadio.SetValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtFormRadio');
  Result := Self;
end;

function TExtFormRadio.SetValue(Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtFormRadio');
  Result := Self;
end;

procedure TExtFormDateField.SetFAltFormats(Value : String); begin
  FAltFormats := Value;
  JSCode('altFormats:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFAutoCreate(Value : String); begin
  FAutoCreate := Value;
  JSCode('autoCreate:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFAutoCreateObject(Value : TExtObject); begin
  FAutoCreateObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoCreate:' + VarToJSON([Value, false]));
end;

procedure TExtFormDateField.SetFDisabledDates(Value : TExtObjectList); begin
  FDisabledDates := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetDisabledDates(Value)
  else
    JSCode('disabledDates:' + VarToJSON([Value, false]));
end;

procedure TExtFormDateField.SetFDisabledDatesText(Value : String); begin
  FDisabledDatesText := Value;
  JSCode('disabledDatesText:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFDisabledDays(Value : TExtObjectList); begin
  FDisabledDays := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetDisabledDays(Value)
  else
    JSCode('disabledDays:' + VarToJSON([Value, false]));
end;

procedure TExtFormDateField.SetFDisabledDaysText(Value : String); begin
  FDisabledDaysText := Value;
  JSCode('disabledDaysText:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFMaxValue(Value : TDateTime); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFMaxValueString(Value : String); begin
  FMaxValueString := Value;
  JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFMinValue(Value : TDateTime); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFMinValueString(Value : String); begin
  FMinValueString := Value;
  JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFShowToday(Value : Boolean); begin
  FShowToday := Value;
  JSCode('showToday:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFTriggerClass(Value : String); begin
  FTriggerClass := Value;
  JSCode('triggerClass:' + VarToJSON([Value]));
end;

procedure TExtFormDateField.SetFOnSelect(Value : TExtFormDateFieldOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    On('select', Ajax('select', ['This', '%0.nm','Date', '%1'], true));
  FOnSelect := Value;
end;

function TExtFormDateField.JSClassName : string; begin
  Result := 'Ext.form.DateField';
end;

procedure TExtFormDateField.InitDefaults; begin
  inherited;
  FAltFormats := 'm/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d';
  FAutoCreateObject := TExtObject.CreateInternal(Self, 'autoCreate');
  FDisabledDates := TExtObjectList.Create(Self, 'disabledDates');
  FDisabledDatesText := 'Disabled';
  FDisabledDays := TExtObjectList.Create(Self, 'disabledDays');
  FDisabledDaysText := 'Disabled';
  FFormat := 'm/d/Y';
  FInvalidText := '{value} is not a valid date - it must be in the format {format}';
  FMaxText := 'The date in this field must be before {maxValue}';
  FMinText := 'The date in this field must be after {minValue}';
  FShowToday := true;
  FTriggerClass := 'x-form-date-trigger';
end;

{$IFDEF FPC}constructor TExtFormDateField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormDateField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormDateField.GetErrors(Value : String) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value]) + ');', 'TExtFormDateField');
  Result := Self;
end;

function TExtFormDateField.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormDateField');
  Result := Self;
end;

function TExtFormDateField.SetDisabledDates(DisabledDates : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.setDisabledDates(' + VarToJSON(DisabledDates) + ');', 'TExtFormDateField');
  Result := Self;
end;

function TExtFormDateField.SetDisabledDays(DisabledDays : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.setDisabledDays(' + VarToJSON(DisabledDays) + ');', 'TExtFormDateField');
  Result := Self;
end;

function TExtFormDateField.SetMaxValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormDateField');
  Result := Self;
end;

function TExtFormDateField.SetMinValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormDateField');
  Result := Self;
end;

function TExtFormDateField.SetValue(Date : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Date]) + ');', 'TExtFormDateField');
  Result := Self;
end;

function TExtFormDateField.SetValue(Date : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Date]) + ');', 'TExtFormDateField');
  Result := Self;
end;

destructor TExtFormDateField.Destroy; begin
  try
    FAutoCreateObject.Free;
    FDisabledDates.Free;
    FDisabledDays.Free;
  except end;
  inherited;
end;

procedure TExtFormDateField.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtFormDateField(ParamAsObject('This')), ParamAsTDateTime('Date'));
end;

procedure TExtFormComboBox.SetFAllQuery(Value : String); begin
  FAllQuery := Value;
  JSCode('allQuery:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFAutoCreate(Value : String); begin
  FAutoCreate := Value;
  JSCode('autoCreate:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFAutoCreateObject(Value : TExtObject); begin
  FAutoCreateObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoCreate:' + VarToJSON([Value, false]));
end;

procedure TExtFormComboBox.SetFAutoSelect(Value : Boolean); begin
  FAutoSelect := Value;
  JSCode('autoSelect:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFClearFilterOnReset(Value : Boolean); begin
  FClearFilterOnReset := Value;
  JSCode('clearFilterOnReset:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFDisplayField(Value : String); begin
  FDisplayField := Value;
  JSCode('displayField:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFForceSelection(Value : Boolean); begin
  FForceSelection := Value;
  JSCode('forceSelection:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFHandleHeight(Value : Integer); begin
  FHandleHeight := Value;
  JSCode('handleHeight:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFHiddenId(Value : String); begin
  FHiddenId := Value;
  JSCode('hiddenId:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFHiddenName(Value : String); begin
  FHiddenName := Value;
  JSCode('hiddenName:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFHiddenValue(Value : String); begin
  FHiddenValue := Value;
  JSCode('hiddenValue:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFItemSelector(Value : String); begin
  FItemSelector := Value;
  JSCode('itemSelector:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFLazyInit(Value : Boolean); begin
  FLazyInit := Value;
  JSCode('lazyInit:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFLazyRender(Value : Boolean); begin
  FLazyRender := Value;
  JSCode('lazyRender:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFListAlign(Value : String); begin
  FListAlign := Value;
  JSCode('listAlign:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFListAlignArray(Value : TExtObjectList); begin
  FListAlignArray := Value;
  Value.DeleteFromGarbage;
  JSCode('listAlign:' + VarToJSON([Value, false]));
end;

procedure TExtFormComboBox.SetFListClass(Value : String); begin
  FListClass := Value;
  JSCode('listClass:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFListEmptyText(Value : String); begin
  FListEmptyText := Value;
  JSCode('listEmptyText:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFListWidth(Value : Integer); begin
  FListWidth := Value;
  JSCode('listWidth:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFLoadingText(Value : String); begin
  FLoadingText := Value;
  JSCode('loadingText:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFMaxHeight(Value : Integer); begin
  FMaxHeight := Value;
  JSCode('maxHeight:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFMinChars(Value : Integer); begin
  FMinChars := Value;
  JSCode('minChars:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFMinHeight(Value : Integer); begin
  FMinHeight := Value;
  JSCode('minHeight:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFMinListWidth(Value : Integer); begin
  FMinListWidth := Value;
  JSCode('minListWidth:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFMode(Value : String); begin
  FMode := Value;
  JSCode('mode:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFPageSize(Value : Integer); begin
  FPageSize := Value;
  JSCode('pageSize:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFQueryDelay(Value : Integer); begin
  FQueryDelay := Value;
  JSCode('queryDelay:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFQueryParam(Value : String); begin
  FQueryParam := Value;
  JSCode('queryParam:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFResizable(Value : Boolean); begin
  FResizable := Value;
  JSCode('resizable:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFSelectOnFocus(Value : Boolean); begin
  FSelectOnFocus := Value;
  JSCode('selectOnFocus:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFSelectedClass(Value : String); begin
  FSelectedClass := Value;
  JSCode('selectedClass:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFShadow(Value : Boolean); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFShadowString(Value : String); begin
  FShadowString := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFStore(Value : TExtDataStore); begin
  FStore.Free;
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtFormComboBox.SetFStoreArray(Value : TExtObjectList); begin
  FStoreArray.Free;
  FStoreArray := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtFormComboBox.SetFSubmitValue(Value : Boolean); begin
  FSubmitValue := Value;
  JSCode('submitValue:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFTpl(Value : String); begin
  FTpl := Value;
  JSCode('tpl:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFTplExtXTemplate(Value : TExtXTemplate); begin
  FTplExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('tpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormComboBox.SetFTransform(Value : String); begin
  FTransform := Value;
  JSCode('transform:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFTriggerAction(Value : String); begin
  FTriggerAction := Value;
  JSCode('triggerAction:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFTriggerClass(Value : String); begin
  FTriggerClass := Value;
  JSCode('triggerClass:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFTypeAhead(Value : Boolean); begin
  FTypeAhead := Value;
  JSCode('typeAhead:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFTypeAheadDelay(Value : Integer); begin
  FTypeAheadDelay := Value;
  JSCode('typeAheadDelay:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFValueField(Value : String); begin
  FValueField := Value;
  JSCode('valueField:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFValueNotFoundText(Value : String); begin
  FValueNotFoundText := Value;
  JSCode('valueNotFoundText:' + VarToJSON([Value]));
end;

procedure TExtFormComboBox.SetFKeyNav(Value : TExtKeyNav); begin
  FKeyNav := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.keyNav=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormComboBox.SetFLastQuery(Value : String); begin
  FLastQuery := Value;
  JSCode(JSName + '.lastQuery=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormComboBox.SetFView(Value : TExtDataView); begin
  FView := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.view=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormComboBox.SetFOnBeforequery(Value : TExtFormComboBoxOnBeforequery); begin
  if Assigned(FOnBeforequery) then
    JSCode(JSName+'.events ["beforequery"].listeners=[];');
  if Assigned(Value) then
    On('beforequery', Ajax('beforequery', ['QueryEvent', '%0.nm'], true));
  FOnBeforequery := Value;
end;

procedure TExtFormComboBox.SetFOnBeforeselect(Value : TExtFormComboBoxOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    On('beforeselect', Ajax('beforeselect', ['Combo', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforeselect := Value;
end;

procedure TExtFormComboBox.SetFOnCollapse(Value : TExtFormComboBoxOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    On('collapse', Ajax('collapse', ['Combo', '%0.nm'], true));
  FOnCollapse := Value;
end;

procedure TExtFormComboBox.SetFOnExpand(Value : TExtFormComboBoxOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    On('expand', Ajax('expand', ['Combo', '%0.nm'], true));
  FOnExpand := Value;
end;

procedure TExtFormComboBox.SetFOnSelect(Value : TExtFormComboBoxOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    On('select', Ajax('select', ['Combo', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnSelect := Value;
end;

function TExtFormComboBox.JSClassName : string; begin
  Result := 'Ext.form.ComboBox';
end;

procedure TExtFormComboBox.InitDefaults; begin
  inherited;
  FAutoCreateObject := TExtObject.CreateInternal(Self, 'autoCreate');
  FAutoSelect := true;
  FClearFilterOnReset := true;
  FDisplayField := 'output/Ext.form.ComboBox.html#Ext.form.ComboBox-mode';
  FHandleHeight := 8;
  FHiddenId := 'output/Ext.form.ComboBox.html#Ext.form.ComboBox-hiddenName';
  FLazyInit := true;
  FListAlign := 'tl-bl?';
  FListAlignArray := TExtObjectList.Create(Self, 'listAlign');
  FLoadingText := 'Loading...';
  FMaxHeight := 300;
  FMinChars := 4;
  FMinHeight := 90;
  FMinListWidth := 70;
  FPageSize := 0;
  FQueryDelay := 500;
  FQueryParam := 'query';
  FSelectOnFocus := true;
  FSelectedClass := 'x-combo-selected';
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FStoreArray := TExtObjectList.Create(Self, 'store');
  FTplExtXTemplate := TExtXTemplate.CreateInternal(Self, 'tpl');
  FTriggerClass := 'x-form-arrow-trigger';
  FTypeAheadDelay := 250;
  FValueField := 'output/Ext.form.ComboBox.html#Ext.form.ComboBox-mode';
  FKeyNav := TExtKeyNav.CreateInternal(Self, 'keyNav');
  FView := TExtDataView.CreateInternal(Self, 'view');
end;

{$IFDEF FPC}constructor TExtFormComboBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormComboBox.Create(const AForcedJSName: string = ''); begin
  if AForcedJSName <> '' then
    FJSName := 'O' + IdentDelim + AForcedJSName + IdentDelim;
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormComboBox.ClearValue : TExtFunction; begin
  JSCode(JSName + '.clearValue();', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.Collapse : TExtFunction; begin
  JSCode(JSName + '.collapse();', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.DoQuery(Query : String; ForceAll : Boolean) : TExtFunction; begin
  JSCode(JSName + '.doQuery(' + VarToJSON([Query, ForceAll]) + ');', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.Expand : TExtFunction; begin
  JSCode(JSName + '.expand();', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.GetListParent : TExtFunction; begin
  JSCode(JSName + '.getListParent();', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.IsExpanded : TExtFunction; begin
  JSCode(JSName + '.isExpanded();', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.Select(Index : Integer; ScrollIntoView : Boolean) : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON([Index, ScrollIntoView]) + ');', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.SelectByValue(Value : String; ScrollIntoView : Boolean) : TExtFunction; begin
  JSCode(JSName + '.selectByValue(' + VarToJSON([Value, ScrollIntoView]) + ');', 'TExtFormComboBox');
  Result := Self;
end;

function TExtFormComboBox.SetValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtFormComboBox');
  Result := Self;
end;

destructor TExtFormComboBox.Destroy; begin
  try
    FAutoCreateObject.Free;
    FListAlignArray.Free;
    FStore.Free;
    FStoreArray.Free;
    FTplExtXTemplate.Free;
    FKeyNav.Free;
    FView.Free;
  except end;
  inherited;
end;

procedure TExtFormComboBox.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforequery') and Assigned(FOnBeforequery) then
    FOnBeforequery(TExtObject(ParamAsObject('QueryEvent')))
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect(TExtFormComboBox(ParamAsObject('Combo')), TExtDataRecord(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse(TExtFormComboBox(ParamAsObject('Combo')))
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand(TExtFormComboBox(ParamAsObject('Combo')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtFormComboBox(ParamAsObject('Combo')), TExtDataRecord(ParamAsObject('RecordJS')), ParamAsInteger('Index'));
end;

procedure TExtFormTwinTriggerField.SetFTrigger1Class(Value : String); begin
  FTrigger1Class := Value;
  JSCode('trigger1Class:' + VarToJSON([Value]));
end;

procedure TExtFormTwinTriggerField.SetFTrigger2Class(Value : String); begin
  FTrigger2Class := Value;
  JSCode('trigger2Class:' + VarToJSON([Value]));
end;

procedure TExtFormTwinTriggerField.SetFTriggerConfig(Value : String); begin
  FTriggerConfig := Value;
  JSCode('triggerConfig:' + VarToJSON([Value]));
end;

function TExtFormTwinTriggerField.JSClassName : string; begin
  Result := 'Ext.form.TwinTriggerField';
end;

procedure TExtFormTwinTriggerField.InitDefaults; begin
  inherited;
end;

{$IFDEF FPC}constructor TExtFormTwinTriggerField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormTwinTriggerField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormTwinTriggerField.OnTrigger1Click(E : TEventObject) : TExtFunction; begin
  JSCode(JSName + '.onTrigger1Click(' + VarToJSON([E, false]) + ');', 'TExtFormTwinTriggerField');
  Result := Self;
end;

function TExtFormTwinTriggerField.OnTrigger2Click(E : TEventObject) : TExtFunction; begin
  JSCode(JSName + '.onTrigger2Click(' + VarToJSON([E, false]) + ');', 'TExtFormTwinTriggerField');
  Result := Self;
end;

procedure TExtFormTimeField.SetFAltFormats(Value : String); begin
  FAltFormats := Value;
  JSCode('altFormats:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFIncrement(Value : Integer); begin
  FIncrement := Value;
  JSCode('increment:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFMaxValue(Value : TDateTime); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFMaxValueString(Value : String); begin
  FMaxValueString := Value;
  JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFMinValue(Value : TDateTime); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormTimeField.SetFMinValueString(Value : String); begin
  FMinValueString := Value;
  JSCode('minValue:' + VarToJSON([Value]));
end;

function TExtFormTimeField.JSClassName : string; begin
  Result := 'Ext.form.TimeField';
end;

procedure TExtFormTimeField.InitDefaults; begin
  inherited;
  FAltFormats := 'g:ia/g:iA/g:i a/g:i A/h:i/g:i/H:i/ga/ha/gA/h a/g a/g A/gi/hi/gia/hia/g/H/gi a/hi a/giA/hiA/gi A/hi A';
  FFormat := 'g:i A';
  FIncrement := 15;
  FInvalidText := '{value} is not a valid time';
  FMaxText := 'The time in this field must be equal to or before {0}';
  FMinText := 'The time in this field must be equal to or after {0}';
end;

{$IFDEF FPC}constructor TExtFormTimeField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormTimeField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormTimeField.SetMaxValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormTimeField');
  Result := Self;
end;

function TExtFormTimeField.SetMaxValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormTimeField');
  Result := Self;
end;

function TExtFormTimeField.SetMinValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormTimeField');
  Result := Self;
end;

function TExtFormTimeField.SetMinValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormTimeField');
  Result := Self;
end;

procedure TExtUxFormLovCombo.SetFSeparator(Value : String); begin
  FSeparator := Value;
  JSCode('separator:' + VarToJSON([Value]));
end;

function TExtUxFormLovCombo.JSClassName : string; begin
  Result := 'Ext.ux.form.LovCombo';
end;

{$IFDEF FPC}constructor TExtUxFormLovCombo.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

initialization
  ExtFormVTypes := TExtFormVTypesSingleton.CreateSingleton;

finalization
  ExtFormVTypes.Destroy;
end.